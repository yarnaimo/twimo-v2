/* tslint:disable */
/* eslint-disable */
/**
 * Twitter API v2
 * Twitter API v2 available endpoints
 *
 * The version of the OpenAPI document: 2.26
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base'

/**
 * @type AddOrDeleteRulesRequest
 * @export
 */
export type AddOrDeleteRulesRequest = AddRulesRequest | DeleteRulesRequest

/**
 * @type AddOrDeleteRulesResponse
 * @export
 */
export type AddOrDeleteRulesResponse = AddRulesResponse | DeleteRulesResponse

/**
 * A request to add a user-specified stream filtering rule.
 * @export
 * @interface AddRulesRequest
 */
export interface AddRulesRequest {
  /**
   *
   * @type {Array<RuleNoId>}
   * @memberof AddRulesRequest
   */
  add: Array<RuleNoId>
}
/**
 * A response from adding user-specified stream filtering rules.
 * @export
 * @interface AddRulesResponse
 */
export interface AddRulesResponse {
  /**
   * All user-specified stream filtering rules that were created.
   * @type {Array<Rule>}
   * @memberof AddRulesResponse
   */
  data: Array<Rule>
  /**
   *
   * @type {RulesResponseMetadata}
   * @memberof AddRulesResponse
   */
  meta: RulesResponseMetadata
}
/**
 *
 * @export
 * @interface AnimatedGif
 */
export interface AnimatedGif {
  /**
   * The Media Key identifier for this attachment.
   * @type {string}
   * @memberof AnimatedGif
   */
  media_key?: string
  /**
   * The height of the media in pixels
   * @type {number}
   * @memberof AnimatedGif
   */
  height?: number
  /**
   * The width of the media in pixels
   * @type {number}
   * @memberof AnimatedGif
   */
  width?: number
  /**
   *
   * @type {string}
   * @memberof AnimatedGif
   */
  type?: AnimatedGifTypeEnum
  /**
   *
   * @type {string}
   * @memberof AnimatedGif
   */
  preview_image_url?: string
}

/**
 * @export
 * @enum {string}
 */
export enum AnimatedGifTypeEnum {
  AnimatedGif = 'animated_gif',
}

/**
 *
 * @export
 * @interface AnimatedGifAllOf
 */
export interface AnimatedGifAllOf {
  /**
   *
   * @type {string}
   * @memberof AnimatedGifAllOf
   */
  type?: AnimatedGifAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof AnimatedGifAllOf
   */
  preview_image_url?: string
}

/**
 * @export
 * @enum {string}
 */
export enum AnimatedGifAllOfTypeEnum {
  AnimatedGif = 'animated_gif',
}

/**
 *
 * @export
 * @interface CashtagEntity
 */
export interface CashtagEntity {
  /**
   * Index (zero-based) at which position this entity starts.  The index is inclusive.
   * @type {number}
   * @memberof CashtagEntity
   */
  start: number
  /**
   * Index (zero-based) at which position this entity ends.  The index is exclusive.
   * @type {number}
   * @memberof CashtagEntity
   */
  end: number
  /**
   *
   * @type {string}
   * @memberof CashtagEntity
   */
  tag: string
}
/**
 * Represent the portion of text recognized as a Cashtag, and its start and end position within the text.
 * @export
 * @interface CashtagFields
 */
export interface CashtagFields {
  /**
   *
   * @type {string}
   * @memberof CashtagFields
   */
  tag: string
}
/**
 * Your client has gone away.
 * @export
 * @interface ClientDisconnectedProblem
 */
export interface ClientDisconnectedProblem {
  /**
   *
   * @type {string}
   * @memberof ClientDisconnectedProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ClientDisconnectedProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof ClientDisconnectedProblem
   */
  type?: ClientDisconnectedProblemTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ClientDisconnectedProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsClientDisconnected = 'https://api.twitter.com/2/problems/client-disconnected',
}

/**
 *
 * @export
 * @interface ClientDisconnectedProblemAllOf
 */
export interface ClientDisconnectedProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof ClientDisconnectedProblemAllOf
   */
  type?: ClientDisconnectedProblemAllOfTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ClientDisconnectedProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsClientDisconnected = 'https://api.twitter.com/2/problems/client-disconnected',
}

/**
 * A problem that indicates your client is forbidden from making this request.
 * @export
 * @interface ClientForbiddenProblem
 */
export interface ClientForbiddenProblem {
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblem
   */
  type?: ClientForbiddenProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblem
   */
  reason?: ClientForbiddenProblemReasonEnum
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblem
   */
  registration_url?: string
}

/**
 * @export
 * @enum {string}
 */
export enum ClientForbiddenProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsClientForbidden = 'https://api.twitter.com/2/problems/client-forbidden',
}
/**
 * @export
 * @enum {string}
 */
export enum ClientForbiddenProblemReasonEnum {
  OfficialClientForbidden = 'official-client-forbidden',
  ClientNotEnrolled = 'client-not-enrolled',
}

/**
 *
 * @export
 * @interface ClientForbiddenProblemAllOf
 */
export interface ClientForbiddenProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblemAllOf
   */
  type?: ClientForbiddenProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblemAllOf
   */
  reason?: ClientForbiddenProblemAllOfReasonEnum
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblemAllOf
   */
  registration_url?: string
}

/**
 * @export
 * @enum {string}
 */
export enum ClientForbiddenProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsClientForbidden = 'https://api.twitter.com/2/problems/client-forbidden',
}
/**
 * @export
 * @enum {string}
 */
export enum ClientForbiddenProblemAllOfReasonEnum {
  OfficialClientForbidden = 'official-client-forbidden',
  ClientNotEnrolled = 'client-not-enrolled',
}

/**
 *
 * @export
 * @interface CommonMediaFields
 */
export interface CommonMediaFields {
  /**
   * The Media Key identifier for this attachment.
   * @type {string}
   * @memberof CommonMediaFields
   */
  media_key?: string
  /**
   * The height of the media in pixels
   * @type {number}
   * @memberof CommonMediaFields
   */
  height?: number
  /**
   * The width of the media in pixels
   * @type {number}
   * @memberof CommonMediaFields
   */
  width?: number
}
/**
 *
 * @export
 * @interface ComplianceJob
 */
export interface ComplianceJob {
  /**
   * Compliance Job ID
   * @type {string}
   * @memberof ComplianceJob
   */
  id: string
  /**
   *
   * @type {ComplianceJobType}
   * @memberof ComplianceJob
   */
  type: ComplianceJobType
  /**
   * Creation time of the compliance job.
   * @type {string}
   * @memberof ComplianceJob
   */
  created_at: string
  /**
   * URL to which the user will upload their tweet or user IDs
   * @type {string}
   * @memberof ComplianceJob
   */
  upload_url: string
  /**
   * Expiration time of the upload URL
   * @type {string}
   * @memberof ComplianceJob
   */
  upload_expires_at: string
  /**
   * URL from which the user will retrieve their compliance results
   * @type {string}
   * @memberof ComplianceJob
   */
  download_url: string
  /**
   * Expiration time of the download URL
   * @type {string}
   * @memberof ComplianceJob
   */
  download_expires_at: string
  /**
   * User-provided name for a compliance job
   * @type {string}
   * @memberof ComplianceJob
   */
  name?: string
  /**
   *
   * @type {ComplianceJobStatus}
   * @memberof ComplianceJob
   */
  status: ComplianceJobStatus
}
/**
 * Status of a compliance job
 * @export
 * @enum {string}
 */
export enum ComplianceJobStatus {
  Created = 'created',
  InProgress = 'in_progress',
  Failed = 'failed',
  Complete = 'complete',
}

/**
 * Type of compliance job to list.
 * @export
 * @enum {string}
 */
export enum ComplianceJobType {
  Tweets = 'tweets',
  Users = 'users',
}

/**
 * You cannot create a new job if one is already in progress.
 * @export
 * @interface ConflictProblem
 */
export interface ConflictProblem {
  /**
   *
   * @type {string}
   * @memberof ConflictProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ConflictProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof ConflictProblem
   */
  type?: ConflictProblemTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ConflictProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsConflict = 'https://api.twitter.com/2/problems/conflict',
}

/**
 *
 * @export
 * @interface ConflictProblemAllOf
 */
export interface ConflictProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof ConflictProblemAllOf
   */
  type?: ConflictProblemAllOfTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ConflictProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsConflict = 'https://api.twitter.com/2/problems/conflict',
}

/**
 * A problem that indicates something is wrong with the connection
 * @export
 * @interface ConnectionExceptionProblem
 */
export interface ConnectionExceptionProblem {
  /**
   *
   * @type {string}
   * @memberof ConnectionExceptionProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ConnectionExceptionProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof ConnectionExceptionProblem
   */
  type?: ConnectionExceptionProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof ConnectionExceptionProblem
   */
  connection_issue?: ConnectionExceptionProblemConnectionIssueEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ConnectionExceptionProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsStreamingConnection = 'https://api.twitter.com/2/problems/streaming-connection',
}
/**
 * @export
 * @enum {string}
 */
export enum ConnectionExceptionProblemConnectionIssueEnum {
  TooManyConnections = 'TooManyConnections',
  ProvisioningSubscription = 'ProvisioningSubscription',
  RuleConfigurationIssue = 'RuleConfigurationIssue',
  RulesInvalidIssue = 'RulesInvalidIssue',
}

/**
 *
 * @export
 * @interface ConnectionExceptionProblemAllOf
 */
export interface ConnectionExceptionProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof ConnectionExceptionProblemAllOf
   */
  type?: ConnectionExceptionProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof ConnectionExceptionProblemAllOf
   */
  connection_issue?: ConnectionExceptionProblemAllOfConnectionIssueEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ConnectionExceptionProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsStreamingConnection = 'https://api.twitter.com/2/problems/streaming-connection',
}
/**
 * @export
 * @enum {string}
 */
export enum ConnectionExceptionProblemAllOfConnectionIssueEnum {
  TooManyConnections = 'TooManyConnections',
  ProvisioningSubscription = 'ProvisioningSubscription',
  RuleConfigurationIssue = 'RuleConfigurationIssue',
  RulesInvalidIssue = 'RulesInvalidIssue',
}

/**
 * Annotation inferred from the tweet text.
 * @export
 * @interface ContextAnnotation
 */
export interface ContextAnnotation {
  /**
   *
   * @type {ContextAnnotationDomainFields}
   * @memberof ContextAnnotation
   */
  domain: ContextAnnotationDomainFields
  /**
   *
   * @type {ContextAnnotationEntityFields}
   * @memberof ContextAnnotation
   */
  entity: ContextAnnotationEntityFields
}
/**
 * Represents the data for the context annotation domain.
 * @export
 * @interface ContextAnnotationDomainFields
 */
export interface ContextAnnotationDomainFields {
  /**
   * The unique id for a context annotation domain.
   * @type {string}
   * @memberof ContextAnnotationDomainFields
   */
  id: string
  /**
   * Name of the context annotation domain.
   * @type {string}
   * @memberof ContextAnnotationDomainFields
   */
  name?: string
  /**
   * Description of the context annotation domain.
   * @type {string}
   * @memberof ContextAnnotationDomainFields
   */
  description?: string
}
/**
 * Represents the data for the context annotation entity.
 * @export
 * @interface ContextAnnotationEntityFields
 */
export interface ContextAnnotationEntityFields {
  /**
   * The unique id for a context annotation entity.
   * @type {string}
   * @memberof ContextAnnotationEntityFields
   */
  id: string
  /**
   * Name of the context annotation entity.
   * @type {string}
   * @memberof ContextAnnotationEntityFields
   */
  name?: string
  /**
   * Description of the context annotation entity.
   * @type {string}
   * @memberof ContextAnnotationEntityFields
   */
  description?: string
}
/**
 * A response from deleting user-specified stream filtering rules.
 * @export
 * @interface DeleteRulesRequest
 */
export interface DeleteRulesRequest {
  /**
   *
   * @type {DeleteRulesRequestDelete}
   * @memberof DeleteRulesRequest
   */
  _delete: DeleteRulesRequestDelete
}
/**
 * IDs and values of all deleted user-specified stream filtering rules.
 * @export
 * @interface DeleteRulesRequestDelete
 */
export interface DeleteRulesRequestDelete {
  /**
   * IDs of all deleted user-specified stream filtering rules.
   * @type {Array<string>}
   * @memberof DeleteRulesRequestDelete
   */
  ids?: Array<string>
  /**
   * Values of all deleted user-specified stream filtering rules.
   * @type {Array<string>}
   * @memberof DeleteRulesRequestDelete
   */
  values?: Array<string>
}
/**
 *
 * @export
 * @interface DeleteRulesResponse
 */
export interface DeleteRulesResponse {
  /**
   *
   * @type {RulesResponseMetadata}
   * @memberof DeleteRulesResponse
   */
  meta: RulesResponseMetadata
}
/**
 * A problem that indicates that the resource requested violates the precepts of this API.
 * @export
 * @interface DisallowedResourceProblem
 */
export interface DisallowedResourceProblem {
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblem
   */
  type?: DisallowedResourceProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblem
   */
  resource_id: string
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblem
   */
  resource_type: DisallowedResourceProblemResourceTypeEnum
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblem
   */
  section: DisallowedResourceProblemSectionEnum
}

/**
 * @export
 * @enum {string}
 */
export enum DisallowedResourceProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsDisallowedResource = 'https://api.twitter.com/2/problems/disallowed-resource',
}
/**
 * @export
 * @enum {string}
 */
export enum DisallowedResourceProblemResourceTypeEnum {
  Tweet = 'tweet',
  Media = 'media',
}
/**
 * @export
 * @enum {string}
 */
export enum DisallowedResourceProblemSectionEnum {
  Data = 'data',
  Includes = 'includes',
}

/**
 *
 * @export
 * @interface DisallowedResourceProblemAllOf
 */
export interface DisallowedResourceProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblemAllOf
   */
  type?: DisallowedResourceProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblemAllOf
   */
  resource_id: string
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblemAllOf
   */
  resource_type: DisallowedResourceProblemAllOfResourceTypeEnum
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblemAllOf
   */
  section: DisallowedResourceProblemAllOfSectionEnum
}

/**
 * @export
 * @enum {string}
 */
export enum DisallowedResourceProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsDisallowedResource = 'https://api.twitter.com/2/problems/disallowed-resource',
}
/**
 * @export
 * @enum {string}
 */
export enum DisallowedResourceProblemAllOfResourceTypeEnum {
  Tweet = 'tweet',
  Media = 'media',
}
/**
 * @export
 * @enum {string}
 */
export enum DisallowedResourceProblemAllOfSectionEnum {
  Data = 'data',
  Includes = 'includes',
}

/**
 * The rule you have submitted is a duplicate.
 * @export
 * @interface DuplicateRuleProblem
 */
export interface DuplicateRuleProblem {
  /**
   *
   * @type {string}
   * @memberof DuplicateRuleProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof DuplicateRuleProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof DuplicateRuleProblem
   */
  type?: DuplicateRuleProblemTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum DuplicateRuleProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsDuplicateRules = 'https://api.twitter.com/2/problems/duplicate-rules',
}

/**
 *
 * @export
 * @interface DuplicateRuleProblemAllOf
 */
export interface DuplicateRuleProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof DuplicateRuleProblemAllOf
   */
  type?: DuplicateRuleProblemAllOfTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum DuplicateRuleProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsDuplicateRules = 'https://api.twitter.com/2/problems/duplicate-rules',
}

/**
 * Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive.
 * @export
 * @interface EntityIndicesInclusiveExclusive
 */
export interface EntityIndicesInclusiveExclusive {
  /**
   * Index (zero-based) at which position this entity starts.  The index is inclusive.
   * @type {number}
   * @memberof EntityIndicesInclusiveExclusive
   */
  start: number
  /**
   * Index (zero-based) at which position this entity ends.  The index is exclusive.
   * @type {number}
   * @memberof EntityIndicesInclusiveExclusive
   */
  end: number
}
/**
 * Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is inclusive.
 * @export
 * @interface EntityIndicesInclusiveInclusive
 */
export interface EntityIndicesInclusiveInclusive {
  /**
   * Index (zero-based) at which position this entity starts.  The index is inclusive.
   * @type {number}
   * @memberof EntityIndicesInclusiveInclusive
   */
  start: number
  /**
   * Index (zero-based) at which position this entity ends.  The index is inclusive.
   * @type {number}
   * @memberof EntityIndicesInclusiveInclusive
   */
  end: number
}
/**
 *
 * @export
 * @interface Expansions
 */
export interface Expansions {
  /**
   *
   * @type {Array<User>}
   * @memberof Expansions
   */
  users?: Array<User>
  /**
   *
   * @type {Array<Tweet>}
   * @memberof Expansions
   */
  tweets?: Array<Tweet>
  /**
   *
   * @type {Array<Place>}
   * @memberof Expansions
   */
  places?: Array<Place>
  /**
   *
   * @type {Array<Media>}
   * @memberof Expansions
   */
  media?: Array<Media>
  /**
   *
   * @type {Array<Poll>}
   * @memberof Expansions
   */
  polls?: Array<Poll>
}
/**
 * A problem that indicates that you are not allowed to see a particular field on a Tweet, User, etc.
 * @export
 * @interface FieldUnauthorizedProblem
 */
export interface FieldUnauthorizedProblem {
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblem
   */
  type?: FieldUnauthorizedProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblem
   */
  section: FieldUnauthorizedProblemSectionEnum
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblem
   */
  resource_type: FieldUnauthorizedProblemResourceTypeEnum
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblem
   */
  field: string
}

/**
 * @export
 * @enum {string}
 */
export enum FieldUnauthorizedProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsNotAuthorizedForField = 'https://api.twitter.com/2/problems/not-authorized-for-field',
}
/**
 * @export
 * @enum {string}
 */
export enum FieldUnauthorizedProblemSectionEnum {
  Data = 'data',
  Includes = 'includes',
}
/**
 * @export
 * @enum {string}
 */
export enum FieldUnauthorizedProblemResourceTypeEnum {
  Tweet = 'tweet',
  Media = 'media',
}

/**
 *
 * @export
 * @interface FieldUnauthorizedProblemAllOf
 */
export interface FieldUnauthorizedProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblemAllOf
   */
  type?: FieldUnauthorizedProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblemAllOf
   */
  section: FieldUnauthorizedProblemAllOfSectionEnum
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblemAllOf
   */
  resource_type: FieldUnauthorizedProblemAllOfResourceTypeEnum
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblemAllOf
   */
  field: string
}

/**
 * @export
 * @enum {string}
 */
export enum FieldUnauthorizedProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsNotAuthorizedForField = 'https://api.twitter.com/2/problems/not-authorized-for-field',
}
/**
 * @export
 * @enum {string}
 */
export enum FieldUnauthorizedProblemAllOfSectionEnum {
  Data = 'data',
  Includes = 'includes',
}
/**
 * @export
 * @enum {string}
 */
export enum FieldUnauthorizedProblemAllOfResourceTypeEnum {
  Tweet = 'tweet',
  Media = 'media',
}

/**
 * @type FilteredStreamingTweet
 * A tweet or error that can be returned by the streaming tweet API
 * @export
 */
export type FilteredStreamingTweet =
  | FilteredStreamingTweetOneOf
  | StreamingTweetOneOf

/**
 * The values returned with a successful streamed tweet. Includes the user provided rules that the tweet matched.
 * @export
 * @interface FilteredStreamingTweetOneOf
 */
export interface FilteredStreamingTweetOneOf {
  /**
   *
   * @type {Tweet}
   * @memberof FilteredStreamingTweetOneOf
   */
  data: Tweet
  /**
   * The list of rules which matched the tweet
   * @type {Array<FilteredStreamingTweetOneOfMatchingRules>}
   * @memberof FilteredStreamingTweetOneOf
   */
  matching_rules: Array<FilteredStreamingTweetOneOfMatchingRules>
  /**
   *
   * @type {Expansions}
   * @memberof FilteredStreamingTweetOneOf
   */
  includes?: Expansions
}
/**
 *
 * @export
 * @interface FilteredStreamingTweetOneOfMatchingRules
 */
export interface FilteredStreamingTweetOneOfMatchingRules {
  /**
   * Unique identifier of this rule.
   * @type {string}
   * @memberof FilteredStreamingTweetOneOfMatchingRules
   */
  id: string
  /**
   * The user-supplied tag assigned to the rule which matched
   * @type {string}
   * @memberof FilteredStreamingTweetOneOfMatchingRules
   */
  tag?: string
}
/**
 *
 * @export
 * @interface FullTextEntities
 */
export interface FullTextEntities {
  /**
   *
   * @type {Array<UrlEntity>}
   * @memberof FullTextEntities
   */
  urls?: Array<UrlEntity>
  /**
   *
   * @type {Array<HashtagEntity>}
   * @memberof FullTextEntities
   */
  hashtags?: Array<HashtagEntity>
  /**
   *
   * @type {Array<MentionEntity>}
   * @memberof FullTextEntities
   */
  mentions?: Array<MentionEntity>
  /**
   *
   * @type {Array<CashtagEntity>}
   * @memberof FullTextEntities
   */
  cashtags?: Array<CashtagEntity>
}
/**
 *
 * @export
 * @interface GenericMultipleUsersLookupResponse
 */
export interface GenericMultipleUsersLookupResponse {
  /**
   *
   * @type {Array<User>}
   * @memberof GenericMultipleUsersLookupResponse
   */
  data?: Array<User>
  /**
   *
   * @type {Expansions}
   * @memberof GenericMultipleUsersLookupResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof GenericMultipleUsersLookupResponse
   */
  errors?: Array<Problem>
  /**
   *
   * @type {GenericMultipleUsersLookupResponseMeta}
   * @memberof GenericMultipleUsersLookupResponse
   */
  meta?: GenericMultipleUsersLookupResponseMeta
}
/**
 *
 * @export
 * @interface GenericMultipleUsersLookupResponseMeta
 */
export interface GenericMultipleUsersLookupResponseMeta {
  /**
   * The previous token
   * @type {string}
   * @memberof GenericMultipleUsersLookupResponseMeta
   */
  previous_token?: string
  /**
   * The next token
   * @type {string}
   * @memberof GenericMultipleUsersLookupResponseMeta
   */
  next_token?: string
  /**
   * The number of user results returned in this response
   * @type {number}
   * @memberof GenericMultipleUsersLookupResponseMeta
   */
  result_count?: number
}
/**
 * A generic problem with no additional information beyond that provided by the HTTP status code.
 * @export
 * @interface GenericProblem
 */
export interface GenericProblem {
  /**
   *
   * @type {string}
   * @memberof GenericProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof GenericProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof GenericProblem
   */
  type?: GenericProblemTypeEnum
  /**
   *
   * @type {number}
   * @memberof GenericProblem
   */
  status: number
}

/**
 * @export
 * @enum {string}
 */
export enum GenericProblemTypeEnum {
  Aboutblank = 'about:blank',
}

/**
 *
 * @export
 * @interface GenericProblemAllOf
 */
export interface GenericProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof GenericProblemAllOf
   */
  type?: GenericProblemAllOfTypeEnum
  /**
   *
   * @type {number}
   * @memberof GenericProblemAllOf
   */
  status: number
}

/**
 * @export
 * @enum {string}
 */
export enum GenericProblemAllOfTypeEnum {
  Aboutblank = 'about:blank',
}

/**
 *
 * @export
 * @interface GenericTweetsTimelineResponse
 */
export interface GenericTweetsTimelineResponse {
  /**
   *
   * @type {Array<Tweet>}
   * @memberof GenericTweetsTimelineResponse
   */
  data?: Array<Tweet>
  /**
   *
   * @type {Expansions}
   * @memberof GenericTweetsTimelineResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof GenericTweetsTimelineResponse
   */
  errors?: Array<Problem>
  /**
   *
   * @type {GenericTweetsTimelineResponseMeta}
   * @memberof GenericTweetsTimelineResponse
   */
  meta?: GenericTweetsTimelineResponseMeta
}
/**
 *
 * @export
 * @interface GenericTweetsTimelineResponseMeta
 */
export interface GenericTweetsTimelineResponseMeta {
  /**
   * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof GenericTweetsTimelineResponseMeta
   */
  newest_id?: string
  /**
   * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof GenericTweetsTimelineResponseMeta
   */
  oldest_id?: string
  /**
   * The previous token
   * @type {string}
   * @memberof GenericTweetsTimelineResponseMeta
   */
  previous_token?: string
  /**
   * The next token
   * @type {string}
   * @memberof GenericTweetsTimelineResponseMeta
   */
  next_token?: string
  /**
   * Number of Tweets in result set
   * @type {number}
   * @memberof GenericTweetsTimelineResponseMeta
   */
  result_count?: number
}
/**
 *
 * @export
 * @interface Geo
 */
export interface Geo {
  /**
   *
   * @type {string}
   * @memberof Geo
   */
  type: GeoTypeEnum
  /**
   *
   * @type {Array<number>}
   * @memberof Geo
   */
  bbox: Array<number>
  /**
   *
   * @type {Point}
   * @memberof Geo
   */
  geometry?: Point
  /**
   *
   * @type {object}
   * @memberof Geo
   */
  properties: object
}

/**
 * @export
 * @enum {string}
 */
export enum GeoTypeEnum {
  Feature = 'Feature',
}

/**
 *
 * @export
 * @enum {string}
 */
export enum Granularity {
  Minute = 'minute',
  Hour = 'hour',
  Day = 'day',
}

/**
 *
 * @export
 * @interface HashtagEntity
 */
export interface HashtagEntity {
  /**
   * Index (zero-based) at which position this entity starts.  The index is inclusive.
   * @type {number}
   * @memberof HashtagEntity
   */
  start: number
  /**
   * Index (zero-based) at which position this entity ends.  The index is exclusive.
   * @type {number}
   * @memberof HashtagEntity
   */
  end: number
  /**
   * The text of the Hashtag
   * @type {string}
   * @memberof HashtagEntity
   */
  tag: string
}
/**
 * Represent the portion of text recognized as a Hashtag, and its start and end position within the text.
 * @export
 * @interface HashtagFields
 */
export interface HashtagFields {
  /**
   * The text of the Hashtag
   * @type {string}
   * @memberof HashtagFields
   */
  tag: string
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   *
   * @type {string}
   * @memberof InlineObject
   */
  target_user_id: string
}
/**
 *
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
  /**
   *
   * @type {string}
   * @memberof InlineObject1
   */
  target_user_id: string
}
/**
 *
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
  /**
   *
   * @type {string}
   * @memberof InlineObject2
   */
  target_user_id: string
}
/**
 *
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
  /**
   *
   * @type {boolean}
   * @memberof InlineObject3
   */
  hidden?: boolean
}
/**
 * A request to create a new batch compliance job.
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
  /**
   *
   * @type {ComplianceJobType}
   * @memberof InlineObject4
   */
  type: ComplianceJobType
  /**
   * If true, this endpoint will return a pre-signed URL with resumable uploads enabled
   * @type {boolean}
   * @memberof InlineObject4
   */
  resumable?: boolean
  /**
   * User-provided name for a compliance job
   * @type {string}
   * @memberof InlineObject4
   */
  name?: string
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {InlineObject3}
   * @memberof InlineResponse200
   */
  data?: InlineObject3
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   *
   * @type {Array<Rule>}
   * @memberof InlineResponse2001
   */
  data: Array<Rule>
  /**
   *
   * @type {RulesResponseMetadata}
   * @memberof InlineResponse2001
   */
  meta: RulesResponseMetadata
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   *
   * @type {Array<Tweet>}
   * @memberof InlineResponse2002
   */
  data?: Array<Tweet>
  /**
   *
   * @type {Expansions}
   * @memberof InlineResponse2002
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof InlineResponse2002
   */
  errors?: Array<Problem>
  /**
   *
   * @type {InlineResponse2002Meta}
   * @memberof InlineResponse2002
   */
  meta?: InlineResponse2002Meta
}
/**
 *
 * @export
 * @interface InlineResponse2002Meta
 */
export interface InlineResponse2002Meta {
  /**
   * The previous token
   * @type {string}
   * @memberof InlineResponse2002Meta
   */
  previous_token?: string
  /**
   * The next token
   * @type {string}
   * @memberof InlineResponse2002Meta
   */
  next_token?: string
  /**
   * Number of Tweets in result set
   * @type {number}
   * @memberof InlineResponse2002Meta
   */
  result_count?: number
}
/**
 * A problem that indicates this request is invalid.
 * @export
 * @interface InvalidRequestProblem
 */
export interface InvalidRequestProblem {
  /**
   *
   * @type {string}
   * @memberof InvalidRequestProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof InvalidRequestProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof InvalidRequestProblem
   */
  type?: InvalidRequestProblemTypeEnum
  /**
   *
   * @type {Array<InvalidRequestProblemAllOfErrors>}
   * @memberof InvalidRequestProblem
   */
  errors?: Array<InvalidRequestProblemAllOfErrors>
}

/**
 * @export
 * @enum {string}
 */
export enum InvalidRequestProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsInvalidRequest = 'https://api.twitter.com/2/problems/invalid-request',
}

/**
 *
 * @export
 * @interface InvalidRequestProblemAllOf
 */
export interface InvalidRequestProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof InvalidRequestProblemAllOf
   */
  type?: InvalidRequestProblemAllOfTypeEnum
  /**
   *
   * @type {Array<InvalidRequestProblemAllOfErrors>}
   * @memberof InvalidRequestProblemAllOf
   */
  errors?: Array<InvalidRequestProblemAllOfErrors>
}

/**
 * @export
 * @enum {string}
 */
export enum InvalidRequestProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsInvalidRequest = 'https://api.twitter.com/2/problems/invalid-request',
}

/**
 *
 * @export
 * @interface InvalidRequestProblemAllOfErrors
 */
export interface InvalidRequestProblemAllOfErrors {
  /**
   *
   * @type {{ [key: string]: Array<string>; }}
   * @memberof InvalidRequestProblemAllOfErrors
   */
  parameters?: { [key: string]: Array<string> }
  /**
   *
   * @type {string}
   * @memberof InvalidRequestProblemAllOfErrors
   */
  message?: string
}
/**
 * The rule you have submitted is invalid.
 * @export
 * @interface InvalidRuleProblem
 */
export interface InvalidRuleProblem {
  /**
   *
   * @type {string}
   * @memberof InvalidRuleProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof InvalidRuleProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof InvalidRuleProblem
   */
  type?: InvalidRuleProblemTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum InvalidRuleProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsInvalidRules = 'https://api.twitter.com/2/problems/invalid-rules',
}

/**
 *
 * @export
 * @interface InvalidRuleProblemAllOf
 */
export interface InvalidRuleProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof InvalidRuleProblemAllOf
   */
  type?: InvalidRuleProblemAllOfTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum InvalidRuleProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsInvalidRules = 'https://api.twitter.com/2/problems/invalid-rules',
}

/**
 * @type Media
 * @export
 */
export type Media = AnimatedGif | Photo | Video

/**
 *
 * @export
 * @interface MentionEntity
 */
export interface MentionEntity {
  /**
   * Index (zero-based) at which position this entity starts.  The index is inclusive.
   * @type {number}
   * @memberof MentionEntity
   */
  start: number
  /**
   * Index (zero-based) at which position this entity ends.  The index is exclusive.
   * @type {number}
   * @memberof MentionEntity
   */
  end: number
  /**
   * The Twitter handle (screen name) of this user.
   * @type {string}
   * @memberof MentionEntity
   */
  username: string
  /**
   * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof MentionEntity
   */
  id: string
}
/**
 * Represent the portion of text recognized as a User mention, and its start and end position within the text.
 * @export
 * @interface MentionFields
 */
export interface MentionFields {
  /**
   * The Twitter handle (screen name) of this user.
   * @type {string}
   * @memberof MentionFields
   */
  username: string
  /**
   * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof MentionFields
   */
  id: string
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {number}
   * @memberof ModelError
   */
  code: number
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  message: string
}
/**
 *
 * @export
 * @interface MultiComplianceJobResponse
 */
export interface MultiComplianceJobResponse {
  /**
   *
   * @type {Array<ComplianceJob>}
   * @memberof MultiComplianceJobResponse
   */
  data?: Array<ComplianceJob>
  /**
   *
   * @type {Array<Problem>}
   * @memberof MultiComplianceJobResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface MultiSpaceLookupResponse
 */
export interface MultiSpaceLookupResponse {
  /**
   *
   * @type {Array<Space>}
   * @memberof MultiSpaceLookupResponse
   */
  data?: Array<Space>
  /**
   *
   * @type {Expansions}
   * @memberof MultiSpaceLookupResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof MultiSpaceLookupResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface MultiTweetLookupResponse
 */
export interface MultiTweetLookupResponse {
  /**
   *
   * @type {Array<Tweet>}
   * @memberof MultiTweetLookupResponse
   */
  data?: Array<Tweet>
  /**
   *
   * @type {Expansions}
   * @memberof MultiTweetLookupResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof MultiTweetLookupResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface MultiUserLookupResponse
 */
export interface MultiUserLookupResponse {
  /**
   *
   * @type {Array<User>}
   * @memberof MultiUserLookupResponse
   */
  data?: Array<User>
  /**
   *
   * @type {Expansions}
   * @memberof MultiUserLookupResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof MultiUserLookupResponse
   */
  errors?: Array<Problem>
}
/**
 * A problem that indicates the user\'s rule set is not compliant.
 * @export
 * @interface NonCompliantRulesProblem
 */
export interface NonCompliantRulesProblem {
  /**
   *
   * @type {string}
   * @memberof NonCompliantRulesProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof NonCompliantRulesProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof NonCompliantRulesProblem
   */
  type?: NonCompliantRulesProblemTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum NonCompliantRulesProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsNoncompliantRules = 'https://api.twitter.com/2/problems/noncompliant-rules',
}

/**
 *
 * @export
 * @interface NonCompliantRulesProblemAllOf
 */
export interface NonCompliantRulesProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof NonCompliantRulesProblemAllOf
   */
  type?: NonCompliantRulesProblemAllOfTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum NonCompliantRulesProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsNoncompliantRules = 'https://api.twitter.com/2/problems/noncompliant-rules',
}

/**
 * You have been disconnected for operational reasons.
 * @export
 * @interface OperationalDisconnectProblem
 */
export interface OperationalDisconnectProblem {
  /**
   *
   * @type {string}
   * @memberof OperationalDisconnectProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof OperationalDisconnectProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof OperationalDisconnectProblem
   */
  type?: OperationalDisconnectProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof OperationalDisconnectProblem
   */
  disconnect_type?: OperationalDisconnectProblemDisconnectTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum OperationalDisconnectProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsOperationalDisconnect = 'https://api.twitter.com/2/problems/operational-disconnect',
}
/**
 * @export
 * @enum {string}
 */
export enum OperationalDisconnectProblemDisconnectTypeEnum {
  OperationalDisconnect = 'OperationalDisconnect',
  UpstreamOperationalDisconnect = 'UpstreamOperationalDisconnect',
  ForceDisconnect = 'ForceDisconnect',
  UpstreamUncleanDisconnect = 'UpstreamUncleanDisconnect',
  SlowReader = 'SlowReader',
  InternalError = 'InternalError',
  ClientApplicationStateDegraded = 'ClientApplicationStateDegraded',
  InvalidRules = 'InvalidRules',
}

/**
 *
 * @export
 * @interface OperationalDisconnectProblemAllOf
 */
export interface OperationalDisconnectProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof OperationalDisconnectProblemAllOf
   */
  type?: OperationalDisconnectProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof OperationalDisconnectProblemAllOf
   */
  disconnect_type?: OperationalDisconnectProblemAllOfDisconnectTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum OperationalDisconnectProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsOperationalDisconnect = 'https://api.twitter.com/2/problems/operational-disconnect',
}
/**
 * @export
 * @enum {string}
 */
export enum OperationalDisconnectProblemAllOfDisconnectTypeEnum {
  OperationalDisconnect = 'OperationalDisconnect',
  UpstreamOperationalDisconnect = 'UpstreamOperationalDisconnect',
  ForceDisconnect = 'ForceDisconnect',
  UpstreamUncleanDisconnect = 'UpstreamUncleanDisconnect',
  SlowReader = 'SlowReader',
  InternalError = 'InternalError',
  ClientApplicationStateDegraded = 'ClientApplicationStateDegraded',
  InvalidRules = 'InvalidRules',
}

/**
 *
 * @export
 * @interface Photo
 */
export interface Photo {
  /**
   * The Media Key identifier for this attachment.
   * @type {string}
   * @memberof Photo
   */
  media_key?: string
  /**
   * The height of the media in pixels
   * @type {number}
   * @memberof Photo
   */
  height?: number
  /**
   * The width of the media in pixels
   * @type {number}
   * @memberof Photo
   */
  width?: number
  /**
   *
   * @type {string}
   * @memberof Photo
   */
  type?: PhotoTypeEnum
  /**
   *
   * @type {string}
   * @memberof Photo
   */
  url?: string
  /**
   *
   * @type {string}
   * @memberof Photo
   */
  alt_text?: string
}

/**
 * @export
 * @enum {string}
 */
export enum PhotoTypeEnum {
  Photo = 'photo',
}

/**
 *
 * @export
 * @interface PhotoAllOf
 */
export interface PhotoAllOf {
  /**
   *
   * @type {string}
   * @memberof PhotoAllOf
   */
  type?: PhotoAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof PhotoAllOf
   */
  url?: string
  /**
   *
   * @type {string}
   * @memberof PhotoAllOf
   */
  alt_text?: string
}

/**
 * @export
 * @enum {string}
 */
export enum PhotoAllOfTypeEnum {
  Photo = 'photo',
}

/**
 *
 * @export
 * @interface Place
 */
export interface Place {
  /**
   * The identifier for this place
   * @type {string}
   * @memberof Place
   */
  id: string
  /**
   * The human readable name of this place.
   * @type {string}
   * @memberof Place
   */
  name?: string
  /**
   * A two-letter ISO 3166-1 alpha-2 country code
   * @type {string}
   * @memberof Place
   */
  country_code?: string
  /**
   *
   * @type {PlaceType}
   * @memberof Place
   */
  place_type?: PlaceType
  /**
   * The full name of this place.
   * @type {string}
   * @memberof Place
   */
  full_name: string
  /**
   * The full name of the county in which this place exists.
   * @type {string}
   * @memberof Place
   */
  country?: string
  /**
   *
   * @type {Array<string>}
   * @memberof Place
   */
  contained_within?: Array<string>
  /**
   *
   * @type {Geo}
   * @memberof Place
   */
  geo?: Geo
}
/**
 *
 * @export
 * @enum {string}
 */
export enum PlaceType {
  Poi = 'poi',
  Neighborhood = 'neighborhood',
  City = 'city',
  Admin = 'admin',
  Country = 'country',
  Unknown = 'unknown',
}

/**
 * A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object.
 * @export
 * @interface Point
 */
export interface Point {
  /**
   *
   * @type {string}
   * @memberof Point
   */
  type: PointTypeEnum
  /**
   * A [GeoJson Position](https://tools.ietf.org/html/rfc7946#section-3.1.1) in the format `[longitude,latitude]`.
   * @type {Array<number>}
   * @memberof Point
   */
  coordinates: Array<number>
}

/**
 * @export
 * @enum {string}
 */
export enum PointTypeEnum {
  Point = 'Point',
}

/**
 * Represent a Poll attached to a Tweet
 * @export
 * @interface Poll
 */
export interface Poll {
  /**
   * Unique identifier of this poll.
   * @type {string}
   * @memberof Poll
   */
  id: string
  /**
   *
   * @type {Array<PollOption>}
   * @memberof Poll
   */
  options: Array<PollOption>
  /**
   *
   * @type {string}
   * @memberof Poll
   */
  voting_status?: PollVotingStatusEnum
  /**
   *
   * @type {string}
   * @memberof Poll
   */
  end_datetime?: string
  /**
   *
   * @type {number}
   * @memberof Poll
   */
  duration_minutes?: number
}

/**
 * @export
 * @enum {string}
 */
export enum PollVotingStatusEnum {
  Open = 'open',
  Closed = 'closed',
}

/**
 * Describes a choice in a Poll object.
 * @export
 * @interface PollOption
 */
export interface PollOption {
  /**
   * Position of this choice in the poll.
   * @type {number}
   * @memberof PollOption
   */
  position: number
  /**
   * The text of a poll choice.
   * @type {string}
   * @memberof PollOption
   */
  label: string
  /**
   * Number of users who voted for this choice.
   * @type {number}
   * @memberof PollOption
   */
  votes: number
}
/**
 * @type Problem
 * An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
 * @export
 */
export type Problem =
  | ClientDisconnectedProblem
  | ClientForbiddenProblem
  | ConflictProblem
  | ConnectionExceptionProblem
  | DisallowedResourceProblem
  | DuplicateRuleProblem
  | FieldUnauthorizedProblem
  | GenericProblem
  | InvalidRequestProblem
  | InvalidRuleProblem
  | NonCompliantRulesProblem
  | OperationalDisconnectProblem
  | ResourceNotFoundProblem
  | ResourceUnauthorizedProblem
  | ResourceUnavailableProblem
  | RulesCapProblem
  | UnsupportedAuthenticationProblem
  | UsageCapExceededProblem

/**
 *
 * @export
 * @interface ProblemFields
 */
export interface ProblemFields {
  /**
   *
   * @type {string}
   * @memberof ProblemFields
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ProblemFields
   */
  detail: string
}
/**
 * Shows who can reply a Tweet. Fields returned are everyone, mentioned_users, and following.
 * @export
 * @enum {string}
 */
export enum ReplySettings {
  Everyone = 'everyone',
  MentionedUsers = 'mentionedUsers',
  Following = 'following',
  Other = 'other',
}

/**
 * A problem that indicates that a given Tweet, User, etc. does not exist.
 * @export
 * @interface ResourceNotFoundProblem
 */
export interface ResourceNotFoundProblem {
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblem
   */
  type?: ResourceNotFoundProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblem
   */
  parameter: string
  /**
   * Value will match the schema of the field.
   * @type {any}
   * @memberof ResourceNotFoundProblem
   */
  value: any | null
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblem
   */
  resource_id: string
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblem
   */
  resource_type: ResourceNotFoundProblemResourceTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ResourceNotFoundProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsResourceNotFound = 'https://api.twitter.com/2/problems/resource-not-found',
}
/**
 * @export
 * @enum {string}
 */
export enum ResourceNotFoundProblemResourceTypeEnum {
  User = 'user',
  Tweet = 'tweet',
  Media = 'media',
}

/**
 *
 * @export
 * @interface ResourceNotFoundProblemAllOf
 */
export interface ResourceNotFoundProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblemAllOf
   */
  type?: ResourceNotFoundProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblemAllOf
   */
  parameter: string
  /**
   * Value will match the schema of the field.
   * @type {any}
   * @memberof ResourceNotFoundProblemAllOf
   */
  value: any | null
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblemAllOf
   */
  resource_id: string
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblemAllOf
   */
  resource_type: ResourceNotFoundProblemAllOfResourceTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ResourceNotFoundProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsResourceNotFound = 'https://api.twitter.com/2/problems/resource-not-found',
}
/**
 * @export
 * @enum {string}
 */
export enum ResourceNotFoundProblemAllOfResourceTypeEnum {
  User = 'user',
  Tweet = 'tweet',
  Media = 'media',
}

/**
 * A problem that indicates you are not allowed to see a particular Tweet, User, etc.
 * @export
 * @interface ResourceUnauthorizedProblem
 */
export interface ResourceUnauthorizedProblem {
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  type?: ResourceUnauthorizedProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  value: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  parameter: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  section: ResourceUnauthorizedProblemSectionEnum
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  resource_id: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  resource_type: ResourceUnauthorizedProblemResourceTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ResourceUnauthorizedProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsNotAuthorizedForResource = 'https://api.twitter.com/2/problems/not-authorized-for-resource',
}
/**
 * @export
 * @enum {string}
 */
export enum ResourceUnauthorizedProblemSectionEnum {
  Data = 'data',
  Includes = 'includes',
}
/**
 * @export
 * @enum {string}
 */
export enum ResourceUnauthorizedProblemResourceTypeEnum {
  Tweet = 'tweet',
  User = 'user',
  Media = 'media',
}

/**
 *
 * @export
 * @interface ResourceUnauthorizedProblemAllOf
 */
export interface ResourceUnauthorizedProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblemAllOf
   */
  type?: ResourceUnauthorizedProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblemAllOf
   */
  value: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblemAllOf
   */
  parameter: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblemAllOf
   */
  section: ResourceUnauthorizedProblemAllOfSectionEnum
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblemAllOf
   */
  resource_id: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblemAllOf
   */
  resource_type: ResourceUnauthorizedProblemAllOfResourceTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ResourceUnauthorizedProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsNotAuthorizedForResource = 'https://api.twitter.com/2/problems/not-authorized-for-resource',
}
/**
 * @export
 * @enum {string}
 */
export enum ResourceUnauthorizedProblemAllOfSectionEnum {
  Data = 'data',
  Includes = 'includes',
}
/**
 * @export
 * @enum {string}
 */
export enum ResourceUnauthorizedProblemAllOfResourceTypeEnum {
  Tweet = 'tweet',
  User = 'user',
  Media = 'media',
}

/**
 * A problem that indicates a particular Tweet, User, etc. is not available to you.
 * @export
 * @interface ResourceUnavailableProblem
 */
export interface ResourceUnavailableProblem {
  /**
   *
   * @type {string}
   * @memberof ResourceUnavailableProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnavailableProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnavailableProblem
   */
  type?: ResourceUnavailableProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof ResourceUnavailableProblem
   */
  parameter: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnavailableProblem
   */
  resource_id: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnavailableProblem
   */
  resource_type: ResourceUnavailableProblemResourceTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ResourceUnavailableProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsResourceUnavailable = 'https://api.twitter.com/2/problems/resource-unavailable',
}
/**
 * @export
 * @enum {string}
 */
export enum ResourceUnavailableProblemResourceTypeEnum {
  User = 'user',
  Tweet = 'tweet',
  Media = 'media',
}

/**
 *
 * @export
 * @interface ResourceUnavailableProblemAllOf
 */
export interface ResourceUnavailableProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof ResourceUnavailableProblemAllOf
   */
  type?: ResourceUnavailableProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof ResourceUnavailableProblemAllOf
   */
  parameter: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnavailableProblemAllOf
   */
  resource_id: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnavailableProblemAllOf
   */
  resource_type: ResourceUnavailableProblemAllOfResourceTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ResourceUnavailableProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsResourceUnavailable = 'https://api.twitter.com/2/problems/resource-unavailable',
}
/**
 * @export
 * @enum {string}
 */
export enum ResourceUnavailableProblemAllOfResourceTypeEnum {
  User = 'user',
  Tweet = 'tweet',
  Media = 'media',
}

/**
 * A user-provided stream filtering rule.
 * @export
 * @interface Rule
 */
export interface Rule {
  /**
   * The filterlang value of the rule.
   * @type {string}
   * @memberof Rule
   */
  value: string
  /**
   * A tag meant for the labeling of user provided rules.
   * @type {string}
   * @memberof Rule
   */
  tag?: string
  /**
   * Unique identifier of this rule.
   * @type {string}
   * @memberof Rule
   */
  id?: string
}
/**
 * A user-provided stream filtering rule.
 * @export
 * @interface RuleNoId
 */
export interface RuleNoId {
  /**
   * The filterlang value of the rule.
   * @type {string}
   * @memberof RuleNoId
   */
  value: string
  /**
   * A tag meant for the labeling of user provided rules.
   * @type {string}
   * @memberof RuleNoId
   */
  tag?: string
}
/**
 * You have exceeded the maximum number of rules.
 * @export
 * @interface RulesCapProblem
 */
export interface RulesCapProblem {
  /**
   *
   * @type {string}
   * @memberof RulesCapProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof RulesCapProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof RulesCapProblem
   */
  type?: RulesCapProblemTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum RulesCapProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsRuleCap = 'https://api.twitter.com/2/problems/rule-cap',
}

/**
 *
 * @export
 * @interface RulesCapProblemAllOf
 */
export interface RulesCapProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof RulesCapProblemAllOf
   */
  type?: RulesCapProblemAllOfTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum RulesCapProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsRuleCap = 'https://api.twitter.com/2/problems/rule-cap',
}

/**
 * @type RulesRequestSummary
 * @export
 */
export type RulesRequestSummary =
  | RulesRequestSummaryOneOf
  | RulesRequestSummaryOneOf1

/**
 * A summary of the results of the addition of user-specified stream filtering rules.
 * @export
 * @interface RulesRequestSummaryOneOf
 */
export interface RulesRequestSummaryOneOf {
  /**
   * Number of user-specified stream filtering rules that were created.
   * @type {number}
   * @memberof RulesRequestSummaryOneOf
   */
  created: number
  /**
   * Number of user-specified stream filtering rules that were not created.
   * @type {number}
   * @memberof RulesRequestSummaryOneOf
   */
  not_created: number
  /**
   * Number of valid user-specified stream filtering rules.
   * @type {number}
   * @memberof RulesRequestSummaryOneOf
   */
  valid: number
  /**
   * Number of invalid user-specified stream filtering rules.
   * @type {number}
   * @memberof RulesRequestSummaryOneOf
   */
  invalid: number
}
/**
 *
 * @export
 * @interface RulesRequestSummaryOneOf1
 */
export interface RulesRequestSummaryOneOf1 {
  /**
   * Number of user-specified stream filtering rules that were deleted.
   * @type {number}
   * @memberof RulesRequestSummaryOneOf1
   */
  deleted: number
  /**
   * Number of user-specified stream filtering rules that were not deleted.
   * @type {number}
   * @memberof RulesRequestSummaryOneOf1
   */
  not_deleted: number
}
/**
 *
 * @export
 * @interface RulesResponseMetadata
 */
export interface RulesResponseMetadata {
  /**
   *
   * @type {string}
   * @memberof RulesResponseMetadata
   */
  sent: string
  /**
   *
   * @type {RulesRequestSummary}
   * @memberof RulesResponseMetadata
   */
  summary?: RulesRequestSummary
}
/**
 * Represent a Search Count Result
 * @export
 * @interface SearchCount
 */
export interface SearchCount {
  /**
   * The end time of the bucket
   * @type {string}
   * @memberof SearchCount
   */
  end: string
  /**
   * The start time of the bucket
   * @type {string}
   * @memberof SearchCount
   */
  start: string
  /**
   * The count for the bucket
   * @type {number}
   * @memberof SearchCount
   */
  tweet_count: number
}
/**
 *
 * @export
 * @interface SingleComplianceJobResponse
 */
export interface SingleComplianceJobResponse {
  /**
   *
   * @type {ComplianceJob}
   * @memberof SingleComplianceJobResponse
   */
  data?: ComplianceJob
  /**
   *
   * @type {Array<Problem>}
   * @memberof SingleComplianceJobResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface SingleSpaceLookupResponse
 */
export interface SingleSpaceLookupResponse {
  /**
   *
   * @type {Space}
   * @memberof SingleSpaceLookupResponse
   */
  data?: Space
  /**
   *
   * @type {Expansions}
   * @memberof SingleSpaceLookupResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof SingleSpaceLookupResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface SingleTweetLookupResponse
 */
export interface SingleTweetLookupResponse {
  /**
   *
   * @type {Tweet}
   * @memberof SingleTweetLookupResponse
   */
  data?: Tweet
  /**
   *
   * @type {Expansions}
   * @memberof SingleTweetLookupResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof SingleTweetLookupResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface SingleUserLookupResponse
 */
export interface SingleUserLookupResponse {
  /**
   *
   * @type {User}
   * @memberof SingleUserLookupResponse
   */
  data?: User
  /**
   *
   * @type {Expansions}
   * @memberof SingleUserLookupResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof SingleUserLookupResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface Space
 */
export interface Space {
  /**
   * The unique identifier of this Space.
   * @type {string}
   * @memberof Space
   */
  id: string
  /**
   * The current state of the space.
   * @type {string}
   * @memberof Space
   */
  state: SpaceStateEnum
  /**
   * When the space was started as a date string
   * @type {string}
   * @memberof Space
   */
  started_at?: string
  /**
   * Denotes if the space is a ticketed space
   * @type {boolean}
   * @memberof Space
   */
  is_ticketed?: boolean
  /**
   * The number of participants in a space
   * @type {number}
   * @memberof Space
   */
  participant_count?: number
  /**
   * The title of the space
   * @type {string}
   * @memberof Space
   */
  title?: string
  /**
   * The user ids for the hosts of the space
   * @type {Array<string>}
   * @memberof Space
   */
  host_ids?: Array<string>
  /**
   * When the space was last updated
   * @type {string}
   * @memberof Space
   */
  updated_at?: string
  /**
   * Creation time of the space
   * @type {string}
   * @memberof Space
   */
  created_at?: string
  /**
   * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof Space
   */
  creator_id?: string
  /**
   * The language of the space
   * @type {string}
   * @memberof Space
   */
  lang?: string
  /**
   * An array of user ids for people who were speakers in a space
   * @type {Array<string>}
   * @memberof Space
   */
  speaker_ids?: Array<string>
  /**
   * An array of user ids for people who were invited to a space
   * @type {Array<string>}
   * @memberof Space
   */
  invited_user_ids?: Array<string>
  /**
   * A date time stamp for when a space is scheduled to begin
   * @type {string}
   * @memberof Space
   */
  scheduled_start?: string
}

/**
 * @export
 * @enum {string}
 */
export enum SpaceStateEnum {
  Live = 'live',
  Scheduled = 'scheduled',
  Ended = 'ended',
}

/**
 * @type StreamingTweet
 * A tweet or error that can be returned by the streaming tweet API.
 * @export
 */
export type StreamingTweet = SingleTweetLookupResponse | StreamingTweetOneOf

/**
 *
 * @export
 * @interface StreamingTweetOneOf
 */
export interface StreamingTweetOneOf {
  /**
   *
   * @type {Array<Problem>}
   * @memberof StreamingTweetOneOf
   */
  errors: Array<Problem>
}
/**
 *
 * @export
 * @interface Tweet
 */
export interface Tweet {
  /**
   * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof Tweet
   */
  id: string
  /**
   * Creation time of the Tweet.
   * @type {string}
   * @memberof Tweet
   */
  created_at?: string
  /**
   * The content of the Tweet.
   * @type {string}
   * @memberof Tweet
   */
  text: string
  /**
   * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof Tweet
   */
  author_id?: string
  /**
   * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof Tweet
   */
  in_reply_to_user_id?: string
  /**
   * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof Tweet
   */
  conversation_id?: string
  /**
   *
   * @type {ReplySettings}
   * @memberof Tweet
   */
  reply_settings?: ReplySettings
  /**
   * A list of Tweets this Tweet refers to. For example, if the parent Tweet is a Retweet, a Quoted Tweet or a Reply, it will include the related Tweet referenced to by its parent.
   * @type {Array<TweetReferencedTweets>}
   * @memberof Tweet
   */
  referenced_tweets?: Array<TweetReferencedTweets>
  /**
   *
   * @type {TweetAttachments}
   * @memberof Tweet
   */
  attachments?: TweetAttachments
  /**
   *
   * @type {Array<ContextAnnotation>}
   * @memberof Tweet
   */
  context_annotations?: Array<ContextAnnotation>
  /**
   *
   * @type {TweetWithheld}
   * @memberof Tweet
   */
  withheld?: TweetWithheld
  /**
   *
   * @type {TweetGeo}
   * @memberof Tweet
   */
  geo?: TweetGeo
  /**
   *
   * @type {FullTextEntities}
   * @memberof Tweet
   */
  entities?: FullTextEntities
  /**
   *
   * @type {TweetPublicMetrics}
   * @memberof Tweet
   */
  public_metrics?: TweetPublicMetrics
  /**
   * Indicates if this Tweet contains URLs marked as sensitive, for example content suitable for mature audiences.
   * @type {boolean}
   * @memberof Tweet
   */
  possibly_sensitive?: boolean
  /**
   * Language of the Tweet, if detected by Twitter. Returned as a BCP47 language tag.
   * @type {string}
   * @memberof Tweet
   */
  lang?: string
  /**
   * The name of the app the user Tweeted from.
   * @type {string}
   * @memberof Tweet
   */
  source?: string
  /**
   *
   * @type {TweetNonPublicMetrics}
   * @memberof Tweet
   */
  non_public_metrics?: TweetNonPublicMetrics
  /**
   *
   * @type {TweetPromotedMetrics}
   * @memberof Tweet
   */
  promoted_metrics?: TweetPromotedMetrics
  /**
   *
   * @type {TweetOrganicMetrics}
   * @memberof Tweet
   */
  organic_metrics?: TweetOrganicMetrics
}
/**
 * Specifies the type of attachments (if any) present in this Tweet.
 * @export
 * @interface TweetAttachments
 */
export interface TweetAttachments {
  /**
   * A list of Media Keys for each one of the media attachments (if media are attached).
   * @type {Array<string>}
   * @memberof TweetAttachments
   */
  media_keys?: Array<string>
  /**
   * A list of poll IDs (if polls are attached).
   * @type {Array<string>}
   * @memberof TweetAttachments
   */
  poll_ids?: Array<string>
}
/**
 *
 * @export
 * @interface TweetCountsResponse
 */
export interface TweetCountsResponse {
  /**
   *
   * @type {Array<SearchCount>}
   * @memberof TweetCountsResponse
   */
  data?: Array<SearchCount>
  /**
   *
   * @type {Array<Problem>}
   * @memberof TweetCountsResponse
   */
  errors?: Array<Problem>
  /**
   *
   * @type {TweetCountsResponseMeta}
   * @memberof TweetCountsResponse
   */
  meta?: TweetCountsResponseMeta
}
/**
 *
 * @export
 * @interface TweetCountsResponseMeta
 */
export interface TweetCountsResponseMeta {
  /**
   * This value is used to get the next \'page\' of results by providing it to the next_token parameter.
   * @type {string}
   * @memberof TweetCountsResponseMeta
   */
  next_token?: string
  /**
   * Sum of search query count results
   * @type {number}
   * @memberof TweetCountsResponseMeta
   */
  total_tweet_count?: number
}
/**
 *
 * @export
 * @interface TweetDeleteResponse
 */
export interface TweetDeleteResponse {
  /**
   *
   * @type {TweetDeleteResponseData}
   * @memberof TweetDeleteResponse
   */
  data?: TweetDeleteResponseData
  /**
   *
   * @type {Array<Problem>}
   * @memberof TweetDeleteResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface TweetDeleteResponseData
 */
export interface TweetDeleteResponseData {
  /**
   *
   * @type {boolean}
   * @memberof TweetDeleteResponseData
   */
  deleted: boolean
}
/**
 * The location tagged on the Tweet, if the user provided one.
 * @export
 * @interface TweetGeo
 */
export interface TweetGeo {
  /**
   *
   * @type {Point}
   * @memberof TweetGeo
   */
  coordinates?: Point
  /**
   * The identifier for this place
   * @type {string}
   * @memberof TweetGeo
   */
  place_id?: string
}
/**
 * Nonpublic engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetNonPublicMetrics
 */
export interface TweetNonPublicMetrics {
  /**
   * Number of times this Tweet has been viewed.
   * @type {number}
   * @memberof TweetNonPublicMetrics
   */
  impression_count?: number
}
/**
 * Organic nonpublic engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetOrganicMetrics
 */
export interface TweetOrganicMetrics {
  /**
   * Number of times this Tweet has been viewed.
   * @type {number}
   * @memberof TweetOrganicMetrics
   */
  impression_count: number
  /**
   * Number of times this Tweet has been Retweeted.
   * @type {number}
   * @memberof TweetOrganicMetrics
   */
  retweet_count: number
  /**
   * Number of times this Tweet has been replied to.
   * @type {number}
   * @memberof TweetOrganicMetrics
   */
  reply_count: number
  /**
   * Number of times this Tweet has been liked.
   * @type {number}
   * @memberof TweetOrganicMetrics
   */
  like_count: number
}
/**
 * Promoted nonpublic engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetPromotedMetrics
 */
export interface TweetPromotedMetrics {
  /**
   * Number of times this Tweet has been viewed.
   * @type {number}
   * @memberof TweetPromotedMetrics
   */
  impression_count?: number
  /**
   * Number of times this Tweet has been liked.
   * @type {number}
   * @memberof TweetPromotedMetrics
   */
  like_count?: number
  /**
   * Number of times this Tweet has been replied to.
   * @type {number}
   * @memberof TweetPromotedMetrics
   */
  reply_count?: number
  /**
   * Number of times this Tweet has been Retweeted.
   * @type {number}
   * @memberof TweetPromotedMetrics
   */
  retweet_count?: number
}
/**
 * Engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetPublicMetrics
 */
export interface TweetPublicMetrics {
  /**
   * Number of times this Tweet has been Retweeted.
   * @type {number}
   * @memberof TweetPublicMetrics
   */
  retweet_count: number
  /**
   * Number of times this Tweet has been replied to.
   * @type {number}
   * @memberof TweetPublicMetrics
   */
  reply_count: number
  /**
   * Number of times this Tweet has been liked.
   * @type {number}
   * @memberof TweetPublicMetrics
   */
  like_count: number
  /**
   * Number of times this Tweet has been quoted.
   * @type {number}
   * @memberof TweetPublicMetrics
   */
  quote_count?: number
}
/**
 *
 * @export
 * @interface TweetReferencedTweets
 */
export interface TweetReferencedTweets {
  /**
   *
   * @type {string}
   * @memberof TweetReferencedTweets
   */
  type: TweetReferencedTweetsTypeEnum
  /**
   * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof TweetReferencedTweets
   */
  id: string
}

/**
 * @export
 * @enum {string}
 */
export enum TweetReferencedTweetsTypeEnum {
  Retweeted = 'retweeted',
  Quoted = 'quoted',
  RepliedTo = 'replied_to',
}

/**
 *
 * @export
 * @interface TweetSearchResponse
 */
export interface TweetSearchResponse {
  /**
   *
   * @type {Array<Tweet>}
   * @memberof TweetSearchResponse
   */
  data?: Array<Tweet>
  /**
   *
   * @type {Expansions}
   * @memberof TweetSearchResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof TweetSearchResponse
   */
  errors?: Array<Problem>
  /**
   *
   * @type {TweetSearchResponseMeta}
   * @memberof TweetSearchResponse
   */
  meta?: TweetSearchResponseMeta
}
/**
 *
 * @export
 * @interface TweetSearchResponseMeta
 */
export interface TweetSearchResponseMeta {
  /**
   * Most recent Tweet Id returned by search query
   * @type {string}
   * @memberof TweetSearchResponseMeta
   */
  newest_id?: string
  /**
   * Oldest Tweet Id returned by search query
   * @type {string}
   * @memberof TweetSearchResponseMeta
   */
  oldest_id?: string
  /**
   * This value is used to get the next \'page\' of results by providing it to the next_token parameter.
   * @type {string}
   * @memberof TweetSearchResponseMeta
   */
  next_token?: string
  /**
   * Number of search query results
   * @type {number}
   * @memberof TweetSearchResponseMeta
   */
  result_count?: number
}
/**
 * Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
 * @export
 * @interface TweetWithheld
 */
export interface TweetWithheld {
  /**
   * Indicates if the content is being withheld for on the basis of copyright infringement.
   * @type {boolean}
   * @memberof TweetWithheld
   */
  copyright: boolean
  /**
   * Provides a list of countries where this content is not available.
   * @type {Array<string>}
   * @memberof TweetWithheld
   */
  country_codes: Array<string>
  /**
   * Indicates whether the content being withheld is the `tweet` or a `user`.
   * @type {string}
   * @memberof TweetWithheld
   */
  scope?: TweetWithheldScopeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum TweetWithheldScopeEnum {
  Tweet = 'tweet',
  User = 'user',
}

/**
 * Represent the portion of text recognized as a URL.
 * @export
 * @interface URLFields
 */
export interface URLFields {
  /**
   * A validly formatted URL.
   * @type {string}
   * @memberof URLFields
   */
  url: string
  /**
   * A validly formatted URL.
   * @type {string}
   * @memberof URLFields
   */
  expanded_url?: string
  /**
   * The URL as displayed in the Twitter client.
   * @type {string}
   * @memberof URLFields
   */
  display_url?: string
  /**
   * Fully resolved url
   * @type {string}
   * @memberof URLFields
   */
  unwound_url?: string
  /**
   * HTTP Status Code.
   * @type {number}
   * @memberof URLFields
   */
  status?: number
  /**
   * Title of the page the URL points to.
   * @type {string}
   * @memberof URLFields
   */
  title?: string
  /**
   * Description of the URL landing page.
   * @type {string}
   * @memberof URLFields
   */
  description?: string
  /**
   *
   * @type {Array<URLImage>}
   * @memberof URLFields
   */
  images?: Array<URLImage>
}
/**
 * Represent the information for the URL image
 * @export
 * @interface URLImage
 */
export interface URLImage {
  /**
   * A validly formatted URL.
   * @type {string}
   * @memberof URLImage
   */
  url?: string
  /**
   * The height of the media in pixels
   * @type {number}
   * @memberof URLImage
   */
  height?: number
  /**
   * The width of the media in pixels
   * @type {number}
   * @memberof URLImage
   */
  width?: number
}
/**
 * A problem that indicates that the authentication used is not supported.
 * @export
 * @interface UnsupportedAuthenticationProblem
 */
export interface UnsupportedAuthenticationProblem {
  /**
   *
   * @type {string}
   * @memberof UnsupportedAuthenticationProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof UnsupportedAuthenticationProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof UnsupportedAuthenticationProblem
   */
  type?: UnsupportedAuthenticationProblemTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum UnsupportedAuthenticationProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsUnsupportedAuthentication = 'https://api.twitter.com/2/problems/unsupported-authentication',
}

/**
 *
 * @export
 * @interface UnsupportedAuthenticationProblemAllOf
 */
export interface UnsupportedAuthenticationProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof UnsupportedAuthenticationProblemAllOf
   */
  type?: UnsupportedAuthenticationProblemAllOfTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum UnsupportedAuthenticationProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsUnsupportedAuthentication = 'https://api.twitter.com/2/problems/unsupported-authentication',
}

/**
 * Represent the portion of text recognized as a URL, and its start and end position within the text.
 * @export
 * @interface UrlEntity
 */
export interface UrlEntity {
  /**
   * Index (zero-based) at which position this entity starts.  The index is inclusive.
   * @type {number}
   * @memberof UrlEntity
   */
  start: number
  /**
   * Index (zero-based) at which position this entity ends.  The index is exclusive.
   * @type {number}
   * @memberof UrlEntity
   */
  end: number
  /**
   * A validly formatted URL.
   * @type {string}
   * @memberof UrlEntity
   */
  url: string
  /**
   * A validly formatted URL.
   * @type {string}
   * @memberof UrlEntity
   */
  expanded_url?: string
  /**
   * The URL as displayed in the Twitter client.
   * @type {string}
   * @memberof UrlEntity
   */
  display_url?: string
  /**
   * Fully resolved url
   * @type {string}
   * @memberof UrlEntity
   */
  unwound_url?: string
  /**
   * HTTP Status Code.
   * @type {number}
   * @memberof UrlEntity
   */
  status?: number
  /**
   * Title of the page the URL points to.
   * @type {string}
   * @memberof UrlEntity
   */
  title?: string
  /**
   * Description of the URL landing page.
   * @type {string}
   * @memberof UrlEntity
   */
  description?: string
  /**
   *
   * @type {Array<URLImage>}
   * @memberof UrlEntity
   */
  images?: Array<URLImage>
}
/**
 * A problem that indicates that a usage cap has been exceeded.
 * @export
 * @interface UsageCapExceededProblem
 */
export interface UsageCapExceededProblem {
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblem
   */
  type?: UsageCapExceededProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblem
   */
  period?: UsageCapExceededProblemPeriodEnum
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblem
   */
  scope?: UsageCapExceededProblemScopeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum UsageCapExceededProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsUsageCapped = 'https://api.twitter.com/2/problems/usage-capped',
}
/**
 * @export
 * @enum {string}
 */
export enum UsageCapExceededProblemPeriodEnum {
  Daily = 'Daily',
  Monthly = 'Monthly',
}
/**
 * @export
 * @enum {string}
 */
export enum UsageCapExceededProblemScopeEnum {
  Account = 'Account',
  Product = 'Product',
}

/**
 *
 * @export
 * @interface UsageCapExceededProblemAllOf
 */
export interface UsageCapExceededProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblemAllOf
   */
  type?: UsageCapExceededProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblemAllOf
   */
  period?: UsageCapExceededProblemAllOfPeriodEnum
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblemAllOf
   */
  scope?: UsageCapExceededProblemAllOfScopeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum UsageCapExceededProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsUsageCapped = 'https://api.twitter.com/2/problems/usage-capped',
}
/**
 * @export
 * @enum {string}
 */
export enum UsageCapExceededProblemAllOfPeriodEnum {
  Daily = 'Daily',
  Monthly = 'Monthly',
}
/**
 * @export
 * @enum {string}
 */
export enum UsageCapExceededProblemAllOfScopeEnum {
  Account = 'Account',
  Product = 'Product',
}

/**
 * The Twitter User object
 * @export
 * @interface User
 */
export interface User {
  /**
   * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof User
   */
  id: string
  /**
   * Creation time of this user.
   * @type {string}
   * @memberof User
   */
  created_at?: string
  /**
   * The friendly name of this user, as shown on their profile.
   * @type {string}
   * @memberof User
   */
  name: string
  /**
   * The Twitter handle (screen name) of this user.
   * @type {string}
   * @memberof User
   */
  username: string
  /**
   * Indicates if this user has chosen to protect their Tweets (in other words, if this user\'s Tweets are private).
   * @type {boolean}
   * @memberof User
   */
  _protected?: boolean
  /**
   * Indicate if this user is a verified Twitter User.
   * @type {boolean}
   * @memberof User
   */
  verified?: boolean
  /**
   *
   * @type {UserWithheld}
   * @memberof User
   */
  withheld?: UserWithheld
  /**
   * The URL to the profile image for this user.
   * @type {string}
   * @memberof User
   */
  profile_image_url?: string
  /**
   * The location specified in the user\'s profile, if the user provided one. As this is a freeform value, it may not indicate a valid location, but it may be fuzzily evaluated when performing searches with location queries.
   * @type {string}
   * @memberof User
   */
  location?: string
  /**
   * The URL specified in the user\'s profile.
   * @type {string}
   * @memberof User
   */
  url?: string
  /**
   * The text of this user\'s profile description (also known as bio), if the user provided one.
   * @type {string}
   * @memberof User
   */
  description?: string
  /**
   *
   * @type {UserEntities}
   * @memberof User
   */
  entities?: UserEntities
  /**
   * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof User
   */
  pinned_tweet_id?: string
  /**
   *
   * @type {UserPublicMetrics}
   * @memberof User
   */
  public_metrics?: UserPublicMetrics
}
/**
 * A list of metadata found in the user\'s profile description.
 * @export
 * @interface UserEntities
 */
export interface UserEntities {
  /**
   *
   * @type {UserEntitiesUrl}
   * @memberof UserEntities
   */
  url?: UserEntitiesUrl
  /**
   *
   * @type {FullTextEntities}
   * @memberof UserEntities
   */
  description?: FullTextEntities
}
/**
 * Expanded details for the URL specified in the user\'s profile, with start and end indices.
 * @export
 * @interface UserEntitiesUrl
 */
export interface UserEntitiesUrl {
  /**
   *
   * @type {Array<UrlEntity>}
   * @memberof UserEntitiesUrl
   */
  urls?: Array<UrlEntity>
}
/**
 * A list of metrics for this user
 * @export
 * @interface UserPublicMetrics
 */
export interface UserPublicMetrics {
  /**
   * Number of users who are following this user.
   * @type {number}
   * @memberof UserPublicMetrics
   */
  followers_count: number
  /**
   * Number of users this user is following.
   * @type {number}
   * @memberof UserPublicMetrics
   */
  following_count: number
  /**
   * The number of Tweets (including Retweets) posted by this user.
   * @type {number}
   * @memberof UserPublicMetrics
   */
  tweet_count: number
  /**
   * The number of lists that include this user.
   * @type {number}
   * @memberof UserPublicMetrics
   */
  listed_count: number
}
/**
 * Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
 * @export
 * @interface UserWithheld
 */
export interface UserWithheld {
  /**
   * Provides a list of countries where this content is not available.
   * @type {Array<string>}
   * @memberof UserWithheld
   */
  country_codes: Array<string>
  /**
   * Indicates that the content being withheld is a `user`.
   * @type {string}
   * @memberof UserWithheld
   */
  scope?: UserWithheldScopeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum UserWithheldScopeEnum {
  User = 'user',
}

/**
 *
 * @export
 * @interface UsersBlockingMutationResponse
 */
export interface UsersBlockingMutationResponse {
  /**
   *
   * @type {UsersBlockingMutationResponseData}
   * @memberof UsersBlockingMutationResponse
   */
  data?: UsersBlockingMutationResponseData
  /**
   *
   * @type {Array<Problem>}
   * @memberof UsersBlockingMutationResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface UsersBlockingMutationResponseData
 */
export interface UsersBlockingMutationResponseData {
  /**
   *
   * @type {boolean}
   * @memberof UsersBlockingMutationResponseData
   */
  blocking?: boolean
}
/**
 *
 * @export
 * @interface UsersFollowingCreateResponse
 */
export interface UsersFollowingCreateResponse {
  /**
   *
   * @type {UsersFollowingCreateResponseData}
   * @memberof UsersFollowingCreateResponse
   */
  data?: UsersFollowingCreateResponseData
  /**
   *
   * @type {Array<Problem>}
   * @memberof UsersFollowingCreateResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface UsersFollowingCreateResponseData
 */
export interface UsersFollowingCreateResponseData {
  /**
   *
   * @type {boolean}
   * @memberof UsersFollowingCreateResponseData
   */
  following?: boolean
  /**
   *
   * @type {boolean}
   * @memberof UsersFollowingCreateResponseData
   */
  pending_follow?: boolean
}
/**
 *
 * @export
 * @interface UsersFollowingDeleteResponse
 */
export interface UsersFollowingDeleteResponse {
  /**
   *
   * @type {UsersFollowingDeleteResponseData}
   * @memberof UsersFollowingDeleteResponse
   */
  data?: UsersFollowingDeleteResponseData
  /**
   *
   * @type {Array<Problem>}
   * @memberof UsersFollowingDeleteResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface UsersFollowingDeleteResponseData
 */
export interface UsersFollowingDeleteResponseData {
  /**
   *
   * @type {boolean}
   * @memberof UsersFollowingDeleteResponseData
   */
  following?: boolean
}
/**
 *
 * @export
 * @interface UsersFollowingLookupResponse
 */
export interface UsersFollowingLookupResponse {
  /**
   *
   * @type {Array<User>}
   * @memberof UsersFollowingLookupResponse
   */
  data?: Array<User>
  /**
   *
   * @type {Expansions}
   * @memberof UsersFollowingLookupResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof UsersFollowingLookupResponse
   */
  errors?: Array<Problem>
  /**
   *
   * @type {GenericMultipleUsersLookupResponseMeta}
   * @memberof UsersFollowingLookupResponse
   */
  meta?: GenericMultipleUsersLookupResponseMeta
}
/**
 *
 * @export
 * @interface UsersLikesCreateRequest
 */
export interface UsersLikesCreateRequest {
  /**
   *
   * @type {string}
   * @memberof UsersLikesCreateRequest
   */
  tweet_id: string
}
/**
 *
 * @export
 * @interface UsersLikesCreateResponse
 */
export interface UsersLikesCreateResponse {
  /**
   *
   * @type {UsersLikesCreateResponseData}
   * @memberof UsersLikesCreateResponse
   */
  data?: UsersLikesCreateResponseData
  /**
   *
   * @type {Array<Problem>}
   * @memberof UsersLikesCreateResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface UsersLikesCreateResponseData
 */
export interface UsersLikesCreateResponseData {
  /**
   *
   * @type {boolean}
   * @memberof UsersLikesCreateResponseData
   */
  liked?: boolean
}
/**
 *
 * @export
 * @interface UsersLikesDeleteResponse
 */
export interface UsersLikesDeleteResponse {
  /**
   *
   * @type {UsersLikesCreateResponseData}
   * @memberof UsersLikesDeleteResponse
   */
  data?: UsersLikesCreateResponseData
  /**
   *
   * @type {Array<Problem>}
   * @memberof UsersLikesDeleteResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface UsersMutingMutationResponse
 */
export interface UsersMutingMutationResponse {
  /**
   *
   * @type {UsersMutingMutationResponseData}
   * @memberof UsersMutingMutationResponse
   */
  data?: UsersMutingMutationResponseData
  /**
   *
   * @type {Array<Problem>}
   * @memberof UsersMutingMutationResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface UsersMutingMutationResponseData
 */
export interface UsersMutingMutationResponseData {
  /**
   *
   * @type {boolean}
   * @memberof UsersMutingMutationResponseData
   */
  muting?: boolean
}
/**
 *
 * @export
 * @interface UsersRetweetsCreateRequest
 */
export interface UsersRetweetsCreateRequest {
  /**
   *
   * @type {string}
   * @memberof UsersRetweetsCreateRequest
   */
  tweet_id: string
}
/**
 *
 * @export
 * @interface UsersRetweetsCreateResponse
 */
export interface UsersRetweetsCreateResponse {
  /**
   *
   * @type {UsersRetweetsCreateResponseData}
   * @memberof UsersRetweetsCreateResponse
   */
  data?: UsersRetweetsCreateResponseData
  /**
   *
   * @type {Array<Problem>}
   * @memberof UsersRetweetsCreateResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface UsersRetweetsCreateResponseData
 */
export interface UsersRetweetsCreateResponseData {
  /**
   *
   * @type {boolean}
   * @memberof UsersRetweetsCreateResponseData
   */
  retweeted?: boolean
}
/**
 *
 * @export
 * @interface UsersRetweetsDeleteResponse
 */
export interface UsersRetweetsDeleteResponse {
  /**
   *
   * @type {UsersRetweetsCreateResponseData}
   * @memberof UsersRetweetsDeleteResponse
   */
  data?: UsersRetweetsCreateResponseData
  /**
   *
   * @type {Array<Problem>}
   * @memberof UsersRetweetsDeleteResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface Video
 */
export interface Video {
  /**
   * The Media Key identifier for this attachment.
   * @type {string}
   * @memberof Video
   */
  media_key?: string
  /**
   * The height of the media in pixels
   * @type {number}
   * @memberof Video
   */
  height?: number
  /**
   * The width of the media in pixels
   * @type {number}
   * @memberof Video
   */
  width?: number
  /**
   *
   * @type {string}
   * @memberof Video
   */
  type?: VideoTypeEnum
  /**
   *
   * @type {string}
   * @memberof Video
   */
  preview_image_url?: string
  /**
   *
   * @type {number}
   * @memberof Video
   */
  duration_ms?: number
  /**
   *
   * @type {VideoAllOfPublicMetrics}
   * @memberof Video
   */
  public_metrics?: VideoAllOfPublicMetrics
  /**
   *
   * @type {VideoAllOfNonPublicMetrics}
   * @memberof Video
   */
  non_public_metrics?: VideoAllOfNonPublicMetrics
  /**
   *
   * @type {VideoAllOfOrganicMetrics}
   * @memberof Video
   */
  organic_metrics?: VideoAllOfOrganicMetrics
  /**
   *
   * @type {VideoAllOfPromotedMetrics}
   * @memberof Video
   */
  promoted_metrics?: VideoAllOfPromotedMetrics
}

/**
 * @export
 * @enum {string}
 */
export enum VideoTypeEnum {
  Video = 'video',
}

/**
 *
 * @export
 * @interface VideoAllOf
 */
export interface VideoAllOf {
  /**
   *
   * @type {string}
   * @memberof VideoAllOf
   */
  type?: VideoAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof VideoAllOf
   */
  preview_image_url?: string
  /**
   *
   * @type {number}
   * @memberof VideoAllOf
   */
  duration_ms?: number
  /**
   *
   * @type {VideoAllOfPublicMetrics}
   * @memberof VideoAllOf
   */
  public_metrics?: VideoAllOfPublicMetrics
  /**
   *
   * @type {VideoAllOfNonPublicMetrics}
   * @memberof VideoAllOf
   */
  non_public_metrics?: VideoAllOfNonPublicMetrics
  /**
   *
   * @type {VideoAllOfOrganicMetrics}
   * @memberof VideoAllOf
   */
  organic_metrics?: VideoAllOfOrganicMetrics
  /**
   *
   * @type {VideoAllOfPromotedMetrics}
   * @memberof VideoAllOf
   */
  promoted_metrics?: VideoAllOfPromotedMetrics
}

/**
 * @export
 * @enum {string}
 */
export enum VideoAllOfTypeEnum {
  Video = 'video',
}

/**
 * Nonpublic engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfNonPublicMetrics
 */
export interface VideoAllOfNonPublicMetrics {
  /**
   * Number of users who made it through 0% of the video.
   * @type {number}
   * @memberof VideoAllOfNonPublicMetrics
   */
  playback_0_count?: number
  /**
   * Number of users who made it through 25% of the video.
   * @type {number}
   * @memberof VideoAllOfNonPublicMetrics
   */
  playback_25_count?: number
  /**
   * Number of users who made it through 50% of the video.
   * @type {number}
   * @memberof VideoAllOfNonPublicMetrics
   */
  playback_50_count?: number
  /**
   * Number of users who made it through 75% of the video.
   * @type {number}
   * @memberof VideoAllOfNonPublicMetrics
   */
  playback_75_count?: number
  /**
   * Number of users who made it through 100% of the video.
   * @type {number}
   * @memberof VideoAllOfNonPublicMetrics
   */
  playback_100_count?: number
}
/**
 * Organic nonpublic engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfOrganicMetrics
 */
export interface VideoAllOfOrganicMetrics {
  /**
   * Number of users who made it through 0% of the video.
   * @type {number}
   * @memberof VideoAllOfOrganicMetrics
   */
  playback_0_count?: number
  /**
   * Number of users who made it through 25% of the video.
   * @type {number}
   * @memberof VideoAllOfOrganicMetrics
   */
  playback_25_count?: number
  /**
   * Number of users who made it through 50% of the video.
   * @type {number}
   * @memberof VideoAllOfOrganicMetrics
   */
  playback_50_count?: number
  /**
   * Number of users who made it through 75% of the video.
   * @type {number}
   * @memberof VideoAllOfOrganicMetrics
   */
  playback_75_count?: number
  /**
   * Number of users who made it through 100% of the video.
   * @type {number}
   * @memberof VideoAllOfOrganicMetrics
   */
  playback_100_count?: number
  /**
   * Number of times this video has been viewed.
   * @type {number}
   * @memberof VideoAllOfOrganicMetrics
   */
  view_count?: number
}
/**
 * Promoted nonpublic engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfPromotedMetrics
 */
export interface VideoAllOfPromotedMetrics {
  /**
   * Number of users who made it through 0% of the video.
   * @type {number}
   * @memberof VideoAllOfPromotedMetrics
   */
  playback_0_count?: number
  /**
   * Number of users who made it through 25% of the video.
   * @type {number}
   * @memberof VideoAllOfPromotedMetrics
   */
  playback_25_count?: number
  /**
   * Number of users who made it through 50% of the video.
   * @type {number}
   * @memberof VideoAllOfPromotedMetrics
   */
  playback_50_count?: number
  /**
   * Number of users who made it through 75% of the video.
   * @type {number}
   * @memberof VideoAllOfPromotedMetrics
   */
  playback_75_count?: number
  /**
   * Number of users who made it through 100% of the video.
   * @type {number}
   * @memberof VideoAllOfPromotedMetrics
   */
  playback_100_count?: number
  /**
   * Number of times this video has been viewed.
   * @type {number}
   * @memberof VideoAllOfPromotedMetrics
   */
  view_count?: number
}
/**
 * Engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfPublicMetrics
 */
export interface VideoAllOfPublicMetrics {
  /**
   * Number of times this video has been viewed.
   * @type {number}
   * @memberof VideoAllOfPublicMetrics
   */
  view_count?: number
}

/**
 * ComplianceApi - axios parameter creator
 * @export
 */
export const ComplianceApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Creates a compliance for the given job type
     * @summary Create compliance job
     * @param {InlineObject4} inlineObject4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBatchComplianceJob: async (
      inlineObject4: InlineObject4,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject4' is not null or undefined
      if (inlineObject4 === null || inlineObject4 === undefined) {
        throw new RequiredError(
          'inlineObject4',
          'Required parameter inlineObject4 was null or undefined when calling createBatchComplianceJob.',
        )
      }
      const localVarPath = `/2/compliance/jobs`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const nonString = typeof inlineObject4 !== 'string'
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type'],
            )
          : nonString
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(inlineObject4 !== undefined ? inlineObject4 : {})
        : inlineObject4 || ''

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a single compliance job by ID
     * @summary Get compliance job
     * @param {string} id ID of the compliance job to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBatchComplianceJob: async (
      id: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getBatchComplianceJob.',
        )
      }
      const localVarPath = `/2/compliance/jobs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns recent compliance jobs for a given job type and optional job status
     * @summary List compliance jobs
     * @param {ComplianceJobType} type Type of compliance job to list.
     * @param {ComplianceJobStatus} [status] Status of compliance job to list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchComplianceJobs: async (
      type: ComplianceJobType,
      status?: ComplianceJobStatus,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError(
          'type',
          'Required parameter type was null or undefined when calling listBatchComplianceJobs.',
        )
      }
      const localVarPath = `/2/compliance/jobs`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ComplianceApi - functional programming interface
 * @export
 */
export const ComplianceApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Creates a compliance for the given job type
     * @summary Create compliance job
     * @param {InlineObject4} inlineObject4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createBatchComplianceJob(
      inlineObject4: InlineObject4,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SingleComplianceJobResponse>
    > {
      const localVarAxiosArgs = await ComplianceApiAxiosParamCreator(
        configuration,
      ).createBatchComplianceJob(inlineObject4, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a single compliance job by ID
     * @summary Get compliance job
     * @param {string} id ID of the compliance job to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBatchComplianceJob(
      id: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SingleComplianceJobResponse>
    > {
      const localVarAxiosArgs = await ComplianceApiAxiosParamCreator(
        configuration,
      ).getBatchComplianceJob(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns recent compliance jobs for a given job type and optional job status
     * @summary List compliance jobs
     * @param {ComplianceJobType} type Type of compliance job to list.
     * @param {ComplianceJobStatus} [status] Status of compliance job to list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchComplianceJobs(
      type: ComplianceJobType,
      status?: ComplianceJobStatus,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MultiComplianceJobResponse>
    > {
      const localVarAxiosArgs = await ComplianceApiAxiosParamCreator(
        configuration,
      ).listBatchComplianceJobs(type, status, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * ComplianceApi - factory interface
 * @export
 */
export const ComplianceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Creates a compliance for the given job type
     * @summary Create compliance job
     * @param {InlineObject4} inlineObject4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBatchComplianceJob(
      inlineObject4: InlineObject4,
      options?: any,
    ): AxiosPromise<SingleComplianceJobResponse> {
      return ComplianceApiFp(configuration)
        .createBatchComplianceJob(inlineObject4, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a single compliance job by ID
     * @summary Get compliance job
     * @param {string} id ID of the compliance job to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBatchComplianceJob(
      id: string,
      options?: any,
    ): AxiosPromise<SingleComplianceJobResponse> {
      return ComplianceApiFp(configuration)
        .getBatchComplianceJob(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns recent compliance jobs for a given job type and optional job status
     * @summary List compliance jobs
     * @param {ComplianceJobType} type Type of compliance job to list.
     * @param {ComplianceJobStatus} [status] Status of compliance job to list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchComplianceJobs(
      type: ComplianceJobType,
      status?: ComplianceJobStatus,
      options?: any,
    ): AxiosPromise<MultiComplianceJobResponse> {
      return ComplianceApiFp(configuration)
        .listBatchComplianceJobs(type, status, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for createBatchComplianceJob operation in ComplianceApi.
 * @export
 * @interface ComplianceApiCreateBatchComplianceJobRequest
 */
export interface ComplianceApiCreateBatchComplianceJobRequest {
  /**
   *
   * @type {InlineObject4}
   * @memberof ComplianceApiCreateBatchComplianceJob
   */
  readonly inlineObject4: InlineObject4
}

/**
 * Request parameters for getBatchComplianceJob operation in ComplianceApi.
 * @export
 * @interface ComplianceApiGetBatchComplianceJobRequest
 */
export interface ComplianceApiGetBatchComplianceJobRequest {
  /**
   * ID of the compliance job to retrieve.
   * @type {string}
   * @memberof ComplianceApiGetBatchComplianceJob
   */
  readonly id: string
}

/**
 * Request parameters for listBatchComplianceJobs operation in ComplianceApi.
 * @export
 * @interface ComplianceApiListBatchComplianceJobsRequest
 */
export interface ComplianceApiListBatchComplianceJobsRequest {
  /**
   * Type of compliance job to list.
   * @type {ComplianceJobType}
   * @memberof ComplianceApiListBatchComplianceJobs
   */
  readonly type: ComplianceJobType

  /**
   * Status of compliance job to list.
   * @type {ComplianceJobStatus}
   * @memberof ComplianceApiListBatchComplianceJobs
   */
  readonly status?: ComplianceJobStatus
}

/**
 * ComplianceApi - object-oriented interface
 * @export
 * @class ComplianceApi
 * @extends {BaseAPI}
 */
export class ComplianceApi extends BaseAPI {
  /**
   * Creates a compliance for the given job type
   * @summary Create compliance job
   * @param {ComplianceApiCreateBatchComplianceJobRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComplianceApi
   */
  public createBatchComplianceJob(
    requestParameters: ComplianceApiCreateBatchComplianceJobRequest,
    options?: any,
  ) {
    return ComplianceApiFp(this.configuration)
      .createBatchComplianceJob(requestParameters.inlineObject4, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a single compliance job by ID
   * @summary Get compliance job
   * @param {ComplianceApiGetBatchComplianceJobRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComplianceApi
   */
  public getBatchComplianceJob(
    requestParameters: ComplianceApiGetBatchComplianceJobRequest,
    options?: any,
  ) {
    return ComplianceApiFp(this.configuration)
      .getBatchComplianceJob(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns recent compliance jobs for a given job type and optional job status
   * @summary List compliance jobs
   * @param {ComplianceApiListBatchComplianceJobsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComplianceApi
   */
  public listBatchComplianceJobs(
    requestParameters: ComplianceApiListBatchComplianceJobsRequest,
    options?: any,
  ) {
    return ComplianceApiFp(this.configuration)
      .listBatchComplianceJobs(
        requestParameters.type,
        requestParameters.status,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * GeneralApi - axios parameter creator
 * @export
 */
export const GeneralApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Full open api spec in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
     * @summary Returns the open api spec document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpenApiSpec: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/2/openapi.json`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * GeneralApi - functional programming interface
 * @export
 */
export const GeneralApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Full open api spec in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
     * @summary Returns the open api spec document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOpenApiSpec(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await GeneralApiAxiosParamCreator(
        configuration,
      ).getOpenApiSpec(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * GeneralApi - factory interface
 * @export
 */
export const GeneralApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Full open api spec in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
     * @summary Returns the open api spec document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpenApiSpec(options?: any): AxiosPromise<object> {
      return GeneralApiFp(configuration)
        .getOpenApiSpec(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * GeneralApi - object-oriented interface
 * @export
 * @class GeneralApi
 * @extends {BaseAPI}
 */
export class GeneralApi extends BaseAPI {
  /**
   * Full open api spec in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
   * @summary Returns the open api spec document.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneralApi
   */
  public getOpenApiSpec(options?: any) {
    return GeneralApiFp(this.configuration)
      .getOpenApiSpec(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SpacesApi - axios parameter creator
 * @export
 */
export const SpacesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns a variety of information about the Space specified by the requested ID
     * @summary Space lookup by Space ID
     * @param {string} id The space id to be retrieved
     * @param {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findSpaceById: async (
      id: string,
      spaceFields?: Array<
        | 'created_at'
        | 'creator_id'
        | 'host_ids'
        | 'invited_user_ids'
        | 'is_ticketed'
        | 'lang'
        | 'participant_count'
        | 'scheduled_start'
        | 'speaker_ids'
        | 'started_at'
        | 'title'
        | 'updated_at'
      >,
      expansions?: Array<
        'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling findSpaceById.',
        )
      }
      const localVarPath = `/2/spaces/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (spaceFields) {
        localVarQueryParameter['space.fields'] = spaceFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a variety of information about the Spaces created by the provided User IDs
     * @summary Space lookup by their creators
     * @param {Array<string>} userIds The users to search through
     * @param {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findSpacesByCreatorIds: async (
      userIds: Array<string>,
      spaceFields?: Array<
        | 'created_at'
        | 'creator_id'
        | 'host_ids'
        | 'invited_user_ids'
        | 'is_ticketed'
        | 'lang'
        | 'participant_count'
        | 'scheduled_start'
        | 'speaker_ids'
        | 'started_at'
        | 'title'
        | 'updated_at'
      >,
      expansions?: Array<
        'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userIds' is not null or undefined
      if (userIds === null || userIds === undefined) {
        throw new RequiredError(
          'userIds',
          'Required parameter userIds was null or undefined when calling findSpacesByCreatorIds.',
        )
      }
      const localVarPath = `/2/spaces/by/creator_ids`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (userIds) {
        localVarQueryParameter['user_ids'] = userIds
      }

      if (spaceFields) {
        localVarQueryParameter['space.fields'] = spaceFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a variety of information about the Spaces specified by the requested IDs
     * @summary Space lookup up Space IDs
     * @param {Array<string>} ids A list of space ids
     * @param {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findSpacesByIds: async (
      ids: Array<string>,
      spaceFields?: Array<
        | 'created_at'
        | 'creator_id'
        | 'host_ids'
        | 'invited_user_ids'
        | 'is_ticketed'
        | 'lang'
        | 'participant_count'
        | 'scheduled_start'
        | 'speaker_ids'
        | 'started_at'
        | 'title'
        | 'updated_at'
      >,
      expansions?: Array<
        'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          'ids',
          'Required parameter ids was null or undefined when calling findSpacesByIds.',
        )
      }
      const localVarPath = `/2/spaces`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (ids) {
        localVarQueryParameter['ids'] = ids
      }

      if (spaceFields) {
        localVarQueryParameter['space.fields'] = spaceFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns Spaces that match the provided query.
     * @summary Search for Spaces
     * @param {string} query The search query
     * @param {'live' | 'scheduled' | 'all'} [state] The state of spaces to search for
     * @param {number} [maxResults] The number of results to return. The maximum for this value is 100.
     * @param {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSpaces: async (
      query: string,
      state?: 'live' | 'scheduled' | 'all',
      maxResults?: number,
      spaceFields?: Array<
        | 'created_at'
        | 'creator_id'
        | 'host_ids'
        | 'invited_user_ids'
        | 'is_ticketed'
        | 'lang'
        | 'participant_count'
        | 'scheduled_start'
        | 'speaker_ids'
        | 'started_at'
        | 'title'
        | 'updated_at'
      >,
      expansions?: Array<
        'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      if (query === null || query === undefined) {
        throw new RequiredError(
          'query',
          'Required parameter query was null or undefined when calling searchSpaces.',
        )
      }
      const localVarPath = `/2/spaces/search`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }

      if (state !== undefined) {
        localVarQueryParameter['state'] = state
      }

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (spaceFields) {
        localVarQueryParameter['space.fields'] = spaceFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SpacesApi - functional programming interface
 * @export
 */
export const SpacesApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns a variety of information about the Space specified by the requested ID
     * @summary Space lookup by Space ID
     * @param {string} id The space id to be retrieved
     * @param {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findSpaceById(
      id: string,
      spaceFields?: Array<
        | 'created_at'
        | 'creator_id'
        | 'host_ids'
        | 'invited_user_ids'
        | 'is_ticketed'
        | 'lang'
        | 'participant_count'
        | 'scheduled_start'
        | 'speaker_ids'
        | 'started_at'
        | 'title'
        | 'updated_at'
      >,
      expansions?: Array<
        'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SingleSpaceLookupResponse>
    > {
      const localVarAxiosArgs = await SpacesApiAxiosParamCreator(
        configuration,
      ).findSpaceById(id, spaceFields, expansions, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a variety of information about the Spaces created by the provided User IDs
     * @summary Space lookup by their creators
     * @param {Array<string>} userIds The users to search through
     * @param {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findSpacesByCreatorIds(
      userIds: Array<string>,
      spaceFields?: Array<
        | 'created_at'
        | 'creator_id'
        | 'host_ids'
        | 'invited_user_ids'
        | 'is_ticketed'
        | 'lang'
        | 'participant_count'
        | 'scheduled_start'
        | 'speaker_ids'
        | 'started_at'
        | 'title'
        | 'updated_at'
      >,
      expansions?: Array<
        'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MultiSpaceLookupResponse>
    > {
      const localVarAxiosArgs = await SpacesApiAxiosParamCreator(
        configuration,
      ).findSpacesByCreatorIds(userIds, spaceFields, expansions, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a variety of information about the Spaces specified by the requested IDs
     * @summary Space lookup up Space IDs
     * @param {Array<string>} ids A list of space ids
     * @param {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findSpacesByIds(
      ids: Array<string>,
      spaceFields?: Array<
        | 'created_at'
        | 'creator_id'
        | 'host_ids'
        | 'invited_user_ids'
        | 'is_ticketed'
        | 'lang'
        | 'participant_count'
        | 'scheduled_start'
        | 'speaker_ids'
        | 'started_at'
        | 'title'
        | 'updated_at'
      >,
      expansions?: Array<
        'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MultiSpaceLookupResponse>
    > {
      const localVarAxiosArgs = await SpacesApiAxiosParamCreator(
        configuration,
      ).findSpacesByIds(ids, spaceFields, expansions, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns Spaces that match the provided query.
     * @summary Search for Spaces
     * @param {string} query The search query
     * @param {'live' | 'scheduled' | 'all'} [state] The state of spaces to search for
     * @param {number} [maxResults] The number of results to return. The maximum for this value is 100.
     * @param {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchSpaces(
      query: string,
      state?: 'live' | 'scheduled' | 'all',
      maxResults?: number,
      spaceFields?: Array<
        | 'created_at'
        | 'creator_id'
        | 'host_ids'
        | 'invited_user_ids'
        | 'is_ticketed'
        | 'lang'
        | 'participant_count'
        | 'scheduled_start'
        | 'speaker_ids'
        | 'started_at'
        | 'title'
        | 'updated_at'
      >,
      expansions?: Array<
        'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MultiSpaceLookupResponse>
    > {
      const localVarAxiosArgs = await SpacesApiAxiosParamCreator(
        configuration,
      ).searchSpaces(query, state, maxResults, spaceFields, expansions, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SpacesApi - factory interface
 * @export
 */
export const SpacesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Returns a variety of information about the Space specified by the requested ID
     * @summary Space lookup by Space ID
     * @param {string} id The space id to be retrieved
     * @param {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findSpaceById(
      id: string,
      spaceFields?: Array<
        | 'created_at'
        | 'creator_id'
        | 'host_ids'
        | 'invited_user_ids'
        | 'is_ticketed'
        | 'lang'
        | 'participant_count'
        | 'scheduled_start'
        | 'speaker_ids'
        | 'started_at'
        | 'title'
        | 'updated_at'
      >,
      expansions?: Array<
        'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
      >,
      options?: any,
    ): AxiosPromise<SingleSpaceLookupResponse> {
      return SpacesApiFp(configuration)
        .findSpaceById(id, spaceFields, expansions, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a variety of information about the Spaces created by the provided User IDs
     * @summary Space lookup by their creators
     * @param {Array<string>} userIds The users to search through
     * @param {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findSpacesByCreatorIds(
      userIds: Array<string>,
      spaceFields?: Array<
        | 'created_at'
        | 'creator_id'
        | 'host_ids'
        | 'invited_user_ids'
        | 'is_ticketed'
        | 'lang'
        | 'participant_count'
        | 'scheduled_start'
        | 'speaker_ids'
        | 'started_at'
        | 'title'
        | 'updated_at'
      >,
      expansions?: Array<
        'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
      >,
      options?: any,
    ): AxiosPromise<MultiSpaceLookupResponse> {
      return SpacesApiFp(configuration)
        .findSpacesByCreatorIds(userIds, spaceFields, expansions, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a variety of information about the Spaces specified by the requested IDs
     * @summary Space lookup up Space IDs
     * @param {Array<string>} ids A list of space ids
     * @param {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findSpacesByIds(
      ids: Array<string>,
      spaceFields?: Array<
        | 'created_at'
        | 'creator_id'
        | 'host_ids'
        | 'invited_user_ids'
        | 'is_ticketed'
        | 'lang'
        | 'participant_count'
        | 'scheduled_start'
        | 'speaker_ids'
        | 'started_at'
        | 'title'
        | 'updated_at'
      >,
      expansions?: Array<
        'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
      >,
      options?: any,
    ): AxiosPromise<MultiSpaceLookupResponse> {
      return SpacesApiFp(configuration)
        .findSpacesByIds(ids, spaceFields, expansions, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns Spaces that match the provided query.
     * @summary Search for Spaces
     * @param {string} query The search query
     * @param {'live' | 'scheduled' | 'all'} [state] The state of spaces to search for
     * @param {number} [maxResults] The number of results to return. The maximum for this value is 100.
     * @param {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSpaces(
      query: string,
      state?: 'live' | 'scheduled' | 'all',
      maxResults?: number,
      spaceFields?: Array<
        | 'created_at'
        | 'creator_id'
        | 'host_ids'
        | 'invited_user_ids'
        | 'is_ticketed'
        | 'lang'
        | 'participant_count'
        | 'scheduled_start'
        | 'speaker_ids'
        | 'started_at'
        | 'title'
        | 'updated_at'
      >,
      expansions?: Array<
        'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
      >,
      options?: any,
    ): AxiosPromise<MultiSpaceLookupResponse> {
      return SpacesApiFp(configuration)
        .searchSpaces(
          query,
          state,
          maxResults,
          spaceFields,
          expansions,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for findSpaceById operation in SpacesApi.
 * @export
 * @interface SpacesApiFindSpaceByIdRequest
 */
export interface SpacesApiFindSpaceByIdRequest {
  /**
   * The space id to be retrieved
   * @type {string}
   * @memberof SpacesApiFindSpaceById
   */
  readonly id: string

  /**
   * A comma separated list of Space fields to display.
   * @type {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>}
   * @memberof SpacesApiFindSpaceById
   */
  readonly spaceFields?: Array<
    | 'created_at'
    | 'creator_id'
    | 'host_ids'
    | 'invited_user_ids'
    | 'is_ticketed'
    | 'lang'
    | 'participant_count'
    | 'scheduled_start'
    | 'speaker_ids'
    | 'started_at'
    | 'title'
    | 'updated_at'
  >

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>}
   * @memberof SpacesApiFindSpaceById
   */
  readonly expansions?: Array<
    'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
  >
}

/**
 * Request parameters for findSpacesByCreatorIds operation in SpacesApi.
 * @export
 * @interface SpacesApiFindSpacesByCreatorIdsRequest
 */
export interface SpacesApiFindSpacesByCreatorIdsRequest {
  /**
   * The users to search through
   * @type {Array<string>}
   * @memberof SpacesApiFindSpacesByCreatorIds
   */
  readonly userIds: Array<string>

  /**
   * A comma separated list of Space fields to display.
   * @type {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>}
   * @memberof SpacesApiFindSpacesByCreatorIds
   */
  readonly spaceFields?: Array<
    | 'created_at'
    | 'creator_id'
    | 'host_ids'
    | 'invited_user_ids'
    | 'is_ticketed'
    | 'lang'
    | 'participant_count'
    | 'scheduled_start'
    | 'speaker_ids'
    | 'started_at'
    | 'title'
    | 'updated_at'
  >

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>}
   * @memberof SpacesApiFindSpacesByCreatorIds
   */
  readonly expansions?: Array<
    'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
  >
}

/**
 * Request parameters for findSpacesByIds operation in SpacesApi.
 * @export
 * @interface SpacesApiFindSpacesByIdsRequest
 */
export interface SpacesApiFindSpacesByIdsRequest {
  /**
   * A list of space ids
   * @type {Array<string>}
   * @memberof SpacesApiFindSpacesByIds
   */
  readonly ids: Array<string>

  /**
   * A comma separated list of Space fields to display.
   * @type {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>}
   * @memberof SpacesApiFindSpacesByIds
   */
  readonly spaceFields?: Array<
    | 'created_at'
    | 'creator_id'
    | 'host_ids'
    | 'invited_user_ids'
    | 'is_ticketed'
    | 'lang'
    | 'participant_count'
    | 'scheduled_start'
    | 'speaker_ids'
    | 'started_at'
    | 'title'
    | 'updated_at'
  >

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>}
   * @memberof SpacesApiFindSpacesByIds
   */
  readonly expansions?: Array<
    'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
  >
}

/**
 * Request parameters for searchSpaces operation in SpacesApi.
 * @export
 * @interface SpacesApiSearchSpacesRequest
 */
export interface SpacesApiSearchSpacesRequest {
  /**
   * The search query
   * @type {string}
   * @memberof SpacesApiSearchSpaces
   */
  readonly query: string

  /**
   * The state of spaces to search for
   * @type {'live' | 'scheduled' | 'all'}
   * @memberof SpacesApiSearchSpaces
   */
  readonly state?: 'live' | 'scheduled' | 'all'

  /**
   * The number of results to return. The maximum for this value is 100.
   * @type {number}
   * @memberof SpacesApiSearchSpaces
   */
  readonly maxResults?: number

  /**
   * A comma separated list of Space fields to display.
   * @type {Array<'created_at' | 'creator_id' | 'host_ids' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'title' | 'updated_at'>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly spaceFields?: Array<
    | 'created_at'
    | 'creator_id'
    | 'host_ids'
    | 'invited_user_ids'
    | 'is_ticketed'
    | 'lang'
    | 'participant_count'
    | 'scheduled_start'
    | 'speaker_ids'
    | 'started_at'
    | 'title'
    | 'updated_at'
  >

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'>}
   * @memberof SpacesApiSearchSpaces
   */
  readonly expansions?: Array<
    'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids'
  >
}

/**
 * SpacesApi - object-oriented interface
 * @export
 * @class SpacesApi
 * @extends {BaseAPI}
 */
export class SpacesApi extends BaseAPI {
  /**
   * Returns a variety of information about the Space specified by the requested ID
   * @summary Space lookup by Space ID
   * @param {SpacesApiFindSpaceByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpacesApi
   */
  public findSpaceById(
    requestParameters: SpacesApiFindSpaceByIdRequest,
    options?: any,
  ) {
    return SpacesApiFp(this.configuration)
      .findSpaceById(
        requestParameters.id,
        requestParameters.spaceFields,
        requestParameters.expansions,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a variety of information about the Spaces created by the provided User IDs
   * @summary Space lookup by their creators
   * @param {SpacesApiFindSpacesByCreatorIdsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpacesApi
   */
  public findSpacesByCreatorIds(
    requestParameters: SpacesApiFindSpacesByCreatorIdsRequest,
    options?: any,
  ) {
    return SpacesApiFp(this.configuration)
      .findSpacesByCreatorIds(
        requestParameters.userIds,
        requestParameters.spaceFields,
        requestParameters.expansions,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a variety of information about the Spaces specified by the requested IDs
   * @summary Space lookup up Space IDs
   * @param {SpacesApiFindSpacesByIdsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpacesApi
   */
  public findSpacesByIds(
    requestParameters: SpacesApiFindSpacesByIdsRequest,
    options?: any,
  ) {
    return SpacesApiFp(this.configuration)
      .findSpacesByIds(
        requestParameters.ids,
        requestParameters.spaceFields,
        requestParameters.expansions,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns Spaces that match the provided query.
   * @summary Search for Spaces
   * @param {SpacesApiSearchSpacesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpacesApi
   */
  public searchSpaces(
    requestParameters: SpacesApiSearchSpacesRequest,
    options?: any,
  ) {
    return SpacesApiFp(this.configuration)
      .searchSpaces(
        requestParameters.query,
        requestParameters.state,
        requestParameters.maxResults,
        requestParameters.spaceFields,
        requestParameters.expansions,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TweetsApi - axios parameter creator
 * @export
 */
export const TweetsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     * @summary Add/Delete rules
     * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest
     * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOrDeleteRules: async (
      addOrDeleteRulesRequest: AddOrDeleteRulesRequest,
      dryRun?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addOrDeleteRulesRequest' is not null or undefined
      if (
        addOrDeleteRulesRequest === null ||
        addOrDeleteRulesRequest === undefined
      ) {
        throw new RequiredError(
          'addOrDeleteRulesRequest',
          'Required parameter addOrDeleteRulesRequest was null or undefined when calling addOrDeleteRules.',
        )
      }
      const localVarPath = `/2/tweets/search/stream/rules`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      if (dryRun !== undefined) {
        localVarQueryParameter['dry_run'] = dryRun
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const nonString = typeof addOrDeleteRulesRequest !== 'string'
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type'],
            )
          : nonString
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            addOrDeleteRulesRequest !== undefined
              ? addOrDeleteRulesRequest
              : {},
          )
        : addOrDeleteRulesRequest || ''

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a variety of information about the Tweet specified by the requested ID
     * @summary Tweet lookup by Tweet ID
     * @param {string} id A single Tweet ID.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTweetById: async (
      id: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling findTweetById.',
        )
      }
      const localVarPath = `/2/tweets/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a variety of information about the Tweet specified by the requested ID
     * @summary Tweet lookup by Tweet IDs
     * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTweetsById: async (
      ids: Array<string>,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          'ids',
          'Required parameter ids was null or undefined when calling findTweetsById.',
        )
      }
      const localVarPath = `/2/tweets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (ids) {
        localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv)
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     * @summary Rules lookup
     * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRules: async (
      ids?: Array<string>,
      maxResults?: number,
      paginationToken?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/2/tweets/search/stream/rules`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      if (ids) {
        localVarQueryParameter['ids'] = ids
      }

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (paginationToken !== undefined) {
        localVarQueryParameter['pagination_token'] = paginationToken
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Hides or unhides a reply to an owned conversation.
     * @summary Hide replies
     * @param {string} id The ID of the reply that you want to hide or unhide.
     * @param {InlineObject3} [inlineObject3]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hideReplyById: async (
      id: string,
      inlineObject3?: InlineObject3,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling hideReplyById.',
        )
      }
      const localVarPath = `/2/tweets/{id}/hidden`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserToken required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const nonString = typeof inlineObject3 !== 'string'
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type'],
            )
          : nonString
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(inlineObject3 !== undefined ? inlineObject3 : {})
        : inlineObject3 || ''

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Streams a deterministic 1% of public Tweets.
     * @summary Sample stream
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {number} [backfillMinutes] The number of minutes of backfill requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sampleStream: async (
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      backfillMinutes?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/2/tweets/sample/stream`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (backfillMinutes !== undefined) {
        localVarQueryParameter['backfill_minutes'] = backfillMinutes
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Streams Tweets matching the stream\'s active rule set.
     * @summary Filtered stream
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {number} [backfillMinutes] The number of minutes of backfill requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchStream: async (
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      backfillMinutes?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/2/tweets/search/stream`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (backfillMinutes !== undefined) {
        localVarQueryParameter['backfill_minutes'] = backfillMinutes
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns Tweet Counts that match a search query.
     * @summary Full archive search counts
     * @param {string} query One query/rule/filter for matching Tweets. Up to 2048 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Granularity} [granularity] The granularity for the search counts results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetCountsFullArchiveSearch: async (
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      nextToken?: string,
      granularity?: Granularity,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      if (query === null || query === undefined) {
        throw new RequiredError(
          'query',
          'Required parameter query was null or undefined when calling tweetCountsFullArchiveSearch.',
        )
      }
      const localVarPath = `/2/tweets/counts/all`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] =
          (startTime as any) instanceof Date
            ? (startTime as any).toISOString()
            : startTime
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] =
          (endTime as any) instanceof Date
            ? (endTime as any).toISOString()
            : endTime
      }

      if (sinceId !== undefined) {
        localVarQueryParameter['since_id'] = sinceId
      }

      if (untilId !== undefined) {
        localVarQueryParameter['until_id'] = untilId
      }

      if (nextToken !== undefined) {
        localVarQueryParameter['next_token'] = nextToken
      }

      if (granularity !== undefined) {
        localVarQueryParameter['granularity'] = granularity
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns Tweet Counts from the last 7 days that match a search query.
     * @summary Recent search counts
     * @param {string} query One query/rule/filter for matching Tweets. Up to 2048 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Granularity} [granularity] The granularity for the search counts results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetCountsRecentSearch: async (
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      nextToken?: string,
      granularity?: Granularity,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      if (query === null || query === undefined) {
        throw new RequiredError(
          'query',
          'Required parameter query was null or undefined when calling tweetCountsRecentSearch.',
        )
      }
      const localVarPath = `/2/tweets/counts/recent`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] =
          (startTime as any) instanceof Date
            ? (startTime as any).toISOString()
            : startTime
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] =
          (endTime as any) instanceof Date
            ? (endTime as any).toISOString()
            : endTime
      }

      if (sinceId !== undefined) {
        localVarQueryParameter['since_id'] = sinceId
      }

      if (untilId !== undefined) {
        localVarQueryParameter['until_id'] = untilId
      }

      if (nextToken !== undefined) {
        localVarQueryParameter['next_token'] = nextToken
      }

      if (granularity !== undefined) {
        localVarQueryParameter['granularity'] = granularity
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns Tweets that match a search query.
     * @summary Full-archive search
     * @param {string} query One query/rule/filter for matching Tweets. Up to 1024 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsFullarchiveSearch: async (
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      if (query === null || query === undefined) {
        throw new RequiredError(
          'query',
          'Required parameter query was null or undefined when calling tweetsFullarchiveSearch.',
        )
      }
      const localVarPath = `/2/tweets/search/all`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] =
          (startTime as any) instanceof Date
            ? (startTime as any).toISOString()
            : startTime
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] =
          (endTime as any) instanceof Date
            ? (endTime as any).toISOString()
            : endTime
      }

      if (sinceId !== undefined) {
        localVarQueryParameter['since_id'] = sinceId
      }

      if (untilId !== undefined) {
        localVarQueryParameter['until_id'] = untilId
      }

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (nextToken !== undefined) {
        localVarQueryParameter['next_token'] = nextToken
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns Tweets from the last 7 days that match a search query.
     * @summary Recent search
     * @param {string} query One query/rule/filter for matching Tweets. Up to 512 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsRecentSearch: async (
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      if (query === null || query === undefined) {
        throw new RequiredError(
          'query',
          'Required parameter query was null or undefined when calling tweetsRecentSearch.',
        )
      }
      const localVarPath = `/2/tweets/search/recent`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] =
          (startTime as any) instanceof Date
            ? (startTime as any).toISOString()
            : startTime
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] =
          (endTime as any) instanceof Date
            ? (endTime as any).toISOString()
            : endTime
      }

      if (sinceId !== undefined) {
        localVarQueryParameter['since_id'] = sinceId
      }

      if (untilId !== undefined) {
        localVarQueryParameter['until_id'] = untilId
      }

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (nextToken !== undefined) {
        localVarQueryParameter['next_token'] = nextToken
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Causes the user (in the path) to like the specified tweet. The user in the path must match the user context authorizing the request.
     * @summary Causes the user (in the path) to like the specified tweet
     * @param {string} id The ID of the user that is requesting to like the tweet
     * @param {UsersLikesCreateRequest} [usersLikesCreateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdLike: async (
      id: string,
      usersLikesCreateRequest?: UsersLikesCreateRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdLike.',
        )
      }
      const localVarPath = `/2/users/{id}/likes`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserToken required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const nonString = typeof usersLikesCreateRequest !== 'string'
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type'],
            )
          : nonString
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            usersLikesCreateRequest !== undefined
              ? usersLikesCreateRequest
              : {},
          )
        : usersLikesCreateRequest || ''

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of Tweets liked by the provided User ID
     * @summary Returns Tweet objects liked by the provided User ID
     * @param {string} id The ID of the User to list the liked Tweets of
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdLikedTweets: async (
      id: string,
      maxResults?: number,
      paginationToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdLikedTweets.',
        )
      }
      const localVarPath = `/2/users/{id}/liked_tweets`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (paginationToken !== undefined) {
        localVarQueryParameter['pagination_token'] = paginationToken
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns Tweet objects that mention username associated to the provided User ID
     * @summary User mention timeline by User ID
     * @param {string} id The ID of the User to list mentions of
     * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
     * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdMentions: async (
      id: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      paginationToken?: string,
      startTime?: string,
      endTime?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdMentions.',
        )
      }
      const localVarPath = `/2/users/{id}/mentions`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (sinceId !== undefined) {
        localVarQueryParameter['since_id'] = sinceId
      }

      if (untilId !== undefined) {
        localVarQueryParameter['until_id'] = untilId
      }

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (paginationToken !== undefined) {
        localVarQueryParameter['pagination_token'] = paginationToken
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] =
          (startTime as any) instanceof Date
            ? (startTime as any).toISOString()
            : startTime
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] =
          (endTime as any) instanceof Date
            ? (endTime as any).toISOString()
            : endTime
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Causes the user (in the path) to retweet the specified tweet. The user in the path must match the user context authorizing the request.
     * @summary Causes the user (in the path) to retweet the specified tweet
     * @param {string} id The ID of the user that is requesting to retweet the tweet
     * @param {UsersRetweetsCreateRequest} [usersRetweetsCreateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdRetweets: async (
      id: string,
      usersRetweetsCreateRequest?: UsersRetweetsCreateRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdRetweets.',
        )
      }
      const localVarPath = `/2/users/{id}/retweets`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserToken required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const nonString = typeof usersRetweetsCreateRequest !== 'string'
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type'],
            )
          : nonString
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            usersRetweetsCreateRequest !== undefined
              ? usersRetweetsCreateRequest
              : {},
          )
        : usersRetweetsCreateRequest || ''

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of Tweets authored by the provided User ID
     * @summary User Tweets timeline by User ID
     * @param {string} id The ID of the User to list Tweets of
     * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
     * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
     * @param {number} [maxResults] The maximum number of results
     * @param {Array<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;)
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdTweets: async (
      id: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      exclude?: Array<'replies' | 'retweets'>,
      paginationToken?: string,
      startTime?: string,
      endTime?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdTweets.',
        )
      }
      const localVarPath = `/2/users/{id}/tweets`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (sinceId !== undefined) {
        localVarQueryParameter['since_id'] = sinceId
      }

      if (untilId !== undefined) {
        localVarQueryParameter['until_id'] = untilId
      }

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (exclude) {
        localVarQueryParameter['exclude'] = exclude.join(COLLECTION_FORMATS.csv)
      }

      if (paginationToken !== undefined) {
        localVarQueryParameter['pagination_token'] = paginationToken
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] =
          (startTime as any) instanceof Date
            ? (startTime as any).toISOString()
            : startTime
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] =
          (endTime as any) instanceof Date
            ? (endTime as any).toISOString()
            : endTime
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Causes the user (in the path) to unlike the specified tweet. The user must match the user context authorizing the request
     * @summary Causes the user (in the path) to unlike the specified tweet
     * @param {string} id The ID of the user that is requesting to unlike the tweet
     * @param {string} tweetId The ID of the tweet that the user is requesting to unlike
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdUnlike: async (
      id: string,
      tweetId: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdUnlike.',
        )
      }
      // verify required parameter 'tweetId' is not null or undefined
      if (tweetId === null || tweetId === undefined) {
        throw new RequiredError(
          'tweetId',
          'Required parameter tweetId was null or undefined when calling usersIdUnlike.',
        )
      }
      const localVarPath = `/2/users/{id}/likes/{tweet_id}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'tweet_id'}}`, encodeURIComponent(String(tweetId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserToken required

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Causes the user (in the path) to unretweet the specified tweet. The user must match the user context authorizing the request
     * @summary Causes the user (in the path) to unretweet the specified tweet
     * @param {string} id The ID of the user that is requesting to unretweet the tweet
     * @param {string} sourceTweetId The ID of the tweet that the user is requesting to unretweet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdUnretweets: async (
      id: string,
      sourceTweetId: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdUnretweets.',
        )
      }
      // verify required parameter 'sourceTweetId' is not null or undefined
      if (sourceTweetId === null || sourceTweetId === undefined) {
        throw new RequiredError(
          'sourceTweetId',
          'Required parameter sourceTweetId was null or undefined when calling usersIdUnretweets.',
        )
      }
      const localVarPath = `/2/users/{id}/retweets/{source_tweet_id}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(
          `{${'source_tweet_id'}}`,
          encodeURIComponent(String(sourceTweetId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserToken required

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TweetsApi - functional programming interface
 * @export
 */
export const TweetsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     * @summary Add/Delete rules
     * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest
     * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addOrDeleteRules(
      addOrDeleteRulesRequest: AddOrDeleteRulesRequest,
      dryRun?: boolean,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AddOrDeleteRulesResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).addOrDeleteRules(addOrDeleteRulesRequest, dryRun, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a variety of information about the Tweet specified by the requested ID
     * @summary Tweet lookup by Tweet ID
     * @param {string} id A single Tweet ID.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findTweetById(
      id: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SingleTweetLookupResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).findTweetById(
        id,
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a variety of information about the Tweet specified by the requested ID
     * @summary Tweet lookup by Tweet IDs
     * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findTweetsById(
      ids: Array<string>,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MultiTweetLookupResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).findTweetsById(
        ids,
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     * @summary Rules lookup
     * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRules(
      ids?: Array<string>,
      maxResults?: number,
      paginationToken?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2001>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).getRules(ids, maxResults, paginationToken, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Hides or unhides a reply to an owned conversation.
     * @summary Hide replies
     * @param {string} id The ID of the reply that you want to hide or unhide.
     * @param {InlineObject3} [inlineObject3]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async hideReplyById(
      id: string,
      inlineObject3?: InlineObject3,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse200>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).hideReplyById(id, inlineObject3, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Streams a deterministic 1% of public Tweets.
     * @summary Sample stream
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {number} [backfillMinutes] The number of minutes of backfill requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sampleStream(
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      backfillMinutes?: number,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamingTweet>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).sampleStream(
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        backfillMinutes,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Streams Tweets matching the stream\'s active rule set.
     * @summary Filtered stream
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {number} [backfillMinutes] The number of minutes of backfill requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchStream(
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      backfillMinutes?: number,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<FilteredStreamingTweet>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).searchStream(
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        backfillMinutes,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns Tweet Counts that match a search query.
     * @summary Full archive search counts
     * @param {string} query One query/rule/filter for matching Tweets. Up to 2048 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Granularity} [granularity] The granularity for the search counts results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tweetCountsFullArchiveSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      nextToken?: string,
      granularity?: Granularity,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TweetCountsResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).tweetCountsFullArchiveSearch(
        query,
        startTime,
        endTime,
        sinceId,
        untilId,
        nextToken,
        granularity,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns Tweet Counts from the last 7 days that match a search query.
     * @summary Recent search counts
     * @param {string} query One query/rule/filter for matching Tweets. Up to 2048 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Granularity} [granularity] The granularity for the search counts results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tweetCountsRecentSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      nextToken?: string,
      granularity?: Granularity,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TweetCountsResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).tweetCountsRecentSearch(
        query,
        startTime,
        endTime,
        sinceId,
        untilId,
        nextToken,
        granularity,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns Tweets that match a search query.
     * @summary Full-archive search
     * @param {string} query One query/rule/filter for matching Tweets. Up to 1024 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tweetsFullarchiveSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TweetSearchResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).tweetsFullarchiveSearch(
        query,
        startTime,
        endTime,
        sinceId,
        untilId,
        maxResults,
        nextToken,
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns Tweets from the last 7 days that match a search query.
     * @summary Recent search
     * @param {string} query One query/rule/filter for matching Tweets. Up to 512 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tweetsRecentSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TweetSearchResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).tweetsRecentSearch(
        query,
        startTime,
        endTime,
        sinceId,
        untilId,
        maxResults,
        nextToken,
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Causes the user (in the path) to like the specified tweet. The user in the path must match the user context authorizing the request.
     * @summary Causes the user (in the path) to like the specified tweet
     * @param {string} id The ID of the user that is requesting to like the tweet
     * @param {UsersLikesCreateRequest} [usersLikesCreateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdLike(
      id: string,
      usersLikesCreateRequest?: UsersLikesCreateRequest,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UsersLikesCreateResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).usersIdLike(id, usersLikesCreateRequest, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a list of Tweets liked by the provided User ID
     * @summary Returns Tweet objects liked by the provided User ID
     * @param {string} id The ID of the User to list the liked Tweets of
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdLikedTweets(
      id: string,
      maxResults?: number,
      paginationToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2002>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).usersIdLikedTweets(
        id,
        maxResults,
        paginationToken,
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns Tweet objects that mention username associated to the provided User ID
     * @summary User mention timeline by User ID
     * @param {string} id The ID of the User to list mentions of
     * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
     * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdMentions(
      id: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      paginationToken?: string,
      startTime?: string,
      endTime?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GenericTweetsTimelineResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).usersIdMentions(
        id,
        sinceId,
        untilId,
        maxResults,
        paginationToken,
        startTime,
        endTime,
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Causes the user (in the path) to retweet the specified tweet. The user in the path must match the user context authorizing the request.
     * @summary Causes the user (in the path) to retweet the specified tweet
     * @param {string} id The ID of the user that is requesting to retweet the tweet
     * @param {UsersRetweetsCreateRequest} [usersRetweetsCreateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdRetweets(
      id: string,
      usersRetweetsCreateRequest?: UsersRetweetsCreateRequest,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UsersRetweetsCreateResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).usersIdRetweets(id, usersRetweetsCreateRequest, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a list of Tweets authored by the provided User ID
     * @summary User Tweets timeline by User ID
     * @param {string} id The ID of the User to list Tweets of
     * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
     * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
     * @param {number} [maxResults] The maximum number of results
     * @param {Array<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;)
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdTweets(
      id: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      exclude?: Array<'replies' | 'retweets'>,
      paginationToken?: string,
      startTime?: string,
      endTime?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GenericTweetsTimelineResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).usersIdTweets(
        id,
        sinceId,
        untilId,
        maxResults,
        exclude,
        paginationToken,
        startTime,
        endTime,
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Causes the user (in the path) to unlike the specified tweet. The user must match the user context authorizing the request
     * @summary Causes the user (in the path) to unlike the specified tweet
     * @param {string} id The ID of the user that is requesting to unlike the tweet
     * @param {string} tweetId The ID of the tweet that the user is requesting to unlike
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdUnlike(
      id: string,
      tweetId: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UsersLikesDeleteResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).usersIdUnlike(id, tweetId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Causes the user (in the path) to unretweet the specified tweet. The user must match the user context authorizing the request
     * @summary Causes the user (in the path) to unretweet the specified tweet
     * @param {string} id The ID of the user that is requesting to unretweet the tweet
     * @param {string} sourceTweetId The ID of the tweet that the user is requesting to unretweet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdUnretweets(
      id: string,
      sourceTweetId: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UsersRetweetsDeleteResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).usersIdUnretweets(id, sourceTweetId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * TweetsApi - factory interface
 * @export
 */
export const TweetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     * @summary Add/Delete rules
     * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest
     * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOrDeleteRules(
      addOrDeleteRulesRequest: AddOrDeleteRulesRequest,
      dryRun?: boolean,
      options?: any,
    ): AxiosPromise<AddOrDeleteRulesResponse> {
      return TweetsApiFp(configuration)
        .addOrDeleteRules(addOrDeleteRulesRequest, dryRun, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a variety of information about the Tweet specified by the requested ID
     * @summary Tweet lookup by Tweet ID
     * @param {string} id A single Tweet ID.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTweetById(
      id: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<SingleTweetLookupResponse> {
      return TweetsApiFp(configuration)
        .findTweetById(
          id,
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a variety of information about the Tweet specified by the requested ID
     * @summary Tweet lookup by Tweet IDs
     * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTweetsById(
      ids: Array<string>,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<MultiTweetLookupResponse> {
      return TweetsApiFp(configuration)
        .findTweetsById(
          ids,
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     * @summary Rules lookup
     * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRules(
      ids?: Array<string>,
      maxResults?: number,
      paginationToken?: string,
      options?: any,
    ): AxiosPromise<InlineResponse2001> {
      return TweetsApiFp(configuration)
        .getRules(ids, maxResults, paginationToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Hides or unhides a reply to an owned conversation.
     * @summary Hide replies
     * @param {string} id The ID of the reply that you want to hide or unhide.
     * @param {InlineObject3} [inlineObject3]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hideReplyById(
      id: string,
      inlineObject3?: InlineObject3,
      options?: any,
    ): AxiosPromise<InlineResponse200> {
      return TweetsApiFp(configuration)
        .hideReplyById(id, inlineObject3, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Streams a deterministic 1% of public Tweets.
     * @summary Sample stream
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {number} [backfillMinutes] The number of minutes of backfill requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sampleStream(
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      backfillMinutes?: number,
      options?: any,
    ): AxiosPromise<StreamingTweet> {
      return TweetsApiFp(configuration)
        .sampleStream(
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          backfillMinutes,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Streams Tweets matching the stream\'s active rule set.
     * @summary Filtered stream
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {number} [backfillMinutes] The number of minutes of backfill requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchStream(
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      backfillMinutes?: number,
      options?: any,
    ): AxiosPromise<FilteredStreamingTweet> {
      return TweetsApiFp(configuration)
        .searchStream(
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          backfillMinutes,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns Tweet Counts that match a search query.
     * @summary Full archive search counts
     * @param {string} query One query/rule/filter for matching Tweets. Up to 2048 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Granularity} [granularity] The granularity for the search counts results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetCountsFullArchiveSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      nextToken?: string,
      granularity?: Granularity,
      options?: any,
    ): AxiosPromise<TweetCountsResponse> {
      return TweetsApiFp(configuration)
        .tweetCountsFullArchiveSearch(
          query,
          startTime,
          endTime,
          sinceId,
          untilId,
          nextToken,
          granularity,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns Tweet Counts from the last 7 days that match a search query.
     * @summary Recent search counts
     * @param {string} query One query/rule/filter for matching Tweets. Up to 2048 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Granularity} [granularity] The granularity for the search counts results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetCountsRecentSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      nextToken?: string,
      granularity?: Granularity,
      options?: any,
    ): AxiosPromise<TweetCountsResponse> {
      return TweetsApiFp(configuration)
        .tweetCountsRecentSearch(
          query,
          startTime,
          endTime,
          sinceId,
          untilId,
          nextToken,
          granularity,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns Tweets that match a search query.
     * @summary Full-archive search
     * @param {string} query One query/rule/filter for matching Tweets. Up to 1024 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsFullarchiveSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<TweetSearchResponse> {
      return TweetsApiFp(configuration)
        .tweetsFullarchiveSearch(
          query,
          startTime,
          endTime,
          sinceId,
          untilId,
          maxResults,
          nextToken,
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns Tweets from the last 7 days that match a search query.
     * @summary Recent search
     * @param {string} query One query/rule/filter for matching Tweets. Up to 512 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsRecentSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<TweetSearchResponse> {
      return TweetsApiFp(configuration)
        .tweetsRecentSearch(
          query,
          startTime,
          endTime,
          sinceId,
          untilId,
          maxResults,
          nextToken,
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Causes the user (in the path) to like the specified tweet. The user in the path must match the user context authorizing the request.
     * @summary Causes the user (in the path) to like the specified tweet
     * @param {string} id The ID of the user that is requesting to like the tweet
     * @param {UsersLikesCreateRequest} [usersLikesCreateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdLike(
      id: string,
      usersLikesCreateRequest?: UsersLikesCreateRequest,
      options?: any,
    ): AxiosPromise<UsersLikesCreateResponse> {
      return TweetsApiFp(configuration)
        .usersIdLike(id, usersLikesCreateRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of Tweets liked by the provided User ID
     * @summary Returns Tweet objects liked by the provided User ID
     * @param {string} id The ID of the User to list the liked Tweets of
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdLikedTweets(
      id: string,
      maxResults?: number,
      paginationToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<InlineResponse2002> {
      return TweetsApiFp(configuration)
        .usersIdLikedTweets(
          id,
          maxResults,
          paginationToken,
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns Tweet objects that mention username associated to the provided User ID
     * @summary User mention timeline by User ID
     * @param {string} id The ID of the User to list mentions of
     * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
     * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdMentions(
      id: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      paginationToken?: string,
      startTime?: string,
      endTime?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<GenericTweetsTimelineResponse> {
      return TweetsApiFp(configuration)
        .usersIdMentions(
          id,
          sinceId,
          untilId,
          maxResults,
          paginationToken,
          startTime,
          endTime,
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Causes the user (in the path) to retweet the specified tweet. The user in the path must match the user context authorizing the request.
     * @summary Causes the user (in the path) to retweet the specified tweet
     * @param {string} id The ID of the user that is requesting to retweet the tweet
     * @param {UsersRetweetsCreateRequest} [usersRetweetsCreateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdRetweets(
      id: string,
      usersRetweetsCreateRequest?: UsersRetweetsCreateRequest,
      options?: any,
    ): AxiosPromise<UsersRetweetsCreateResponse> {
      return TweetsApiFp(configuration)
        .usersIdRetweets(id, usersRetweetsCreateRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of Tweets authored by the provided User ID
     * @summary User Tweets timeline by User ID
     * @param {string} id The ID of the User to list Tweets of
     * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
     * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
     * @param {number} [maxResults] The maximum number of results
     * @param {Array<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;)
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdTweets(
      id: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      exclude?: Array<'replies' | 'retweets'>,
      paginationToken?: string,
      startTime?: string,
      endTime?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
        | 'alt_text'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<GenericTweetsTimelineResponse> {
      return TweetsApiFp(configuration)
        .usersIdTweets(
          id,
          sinceId,
          untilId,
          maxResults,
          exclude,
          paginationToken,
          startTime,
          endTime,
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Causes the user (in the path) to unlike the specified tweet. The user must match the user context authorizing the request
     * @summary Causes the user (in the path) to unlike the specified tweet
     * @param {string} id The ID of the user that is requesting to unlike the tweet
     * @param {string} tweetId The ID of the tweet that the user is requesting to unlike
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdUnlike(
      id: string,
      tweetId: string,
      options?: any,
    ): AxiosPromise<UsersLikesDeleteResponse> {
      return TweetsApiFp(configuration)
        .usersIdUnlike(id, tweetId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Causes the user (in the path) to unretweet the specified tweet. The user must match the user context authorizing the request
     * @summary Causes the user (in the path) to unretweet the specified tweet
     * @param {string} id The ID of the user that is requesting to unretweet the tweet
     * @param {string} sourceTweetId The ID of the tweet that the user is requesting to unretweet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdUnretweets(
      id: string,
      sourceTweetId: string,
      options?: any,
    ): AxiosPromise<UsersRetweetsDeleteResponse> {
      return TweetsApiFp(configuration)
        .usersIdUnretweets(id, sourceTweetId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for addOrDeleteRules operation in TweetsApi.
 * @export
 * @interface TweetsApiAddOrDeleteRulesRequest
 */
export interface TweetsApiAddOrDeleteRulesRequest {
  /**
   *
   * @type {AddOrDeleteRulesRequest}
   * @memberof TweetsApiAddOrDeleteRules
   */
  readonly addOrDeleteRulesRequest: AddOrDeleteRulesRequest

  /**
   * Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
   * @type {boolean}
   * @memberof TweetsApiAddOrDeleteRules
   */
  readonly dryRun?: boolean
}

/**
 * Request parameters for findTweetById operation in TweetsApi.
 * @export
 * @interface TweetsApiFindTweetByIdRequest
 */
export interface TweetsApiFindTweetByIdRequest {
  /**
   * A single Tweet ID.
   * @type {string}
   * @memberof TweetsApiFindTweetById
   */
  readonly id: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiFindTweetById
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiFindTweetById
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiFindTweetById
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>}
   * @memberof TweetsApiFindTweetById
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
    | 'alt_text'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiFindTweetById
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiFindTweetById
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * Request parameters for findTweetsById operation in TweetsApi.
 * @export
 * @interface TweetsApiFindTweetsByIdRequest
 */
export interface TweetsApiFindTweetsByIdRequest {
  /**
   * A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
   * @type {Array<string>}
   * @memberof TweetsApiFindTweetsById
   */
  readonly ids: Array<string>

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiFindTweetsById
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiFindTweetsById
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiFindTweetsById
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>}
   * @memberof TweetsApiFindTweetsById
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
    | 'alt_text'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiFindTweetsById
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiFindTweetsById
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * Request parameters for getRules operation in TweetsApi.
 * @export
 * @interface TweetsApiGetRulesRequest
 */
export interface TweetsApiGetRulesRequest {
  /**
   * A comma-separated list of Rule IDs.
   * @type {Array<string>}
   * @memberof TweetsApiGetRules
   */
  readonly ids?: Array<string>

  /**
   * The maximum number of results
   * @type {number}
   * @memberof TweetsApiGetRules
   */
  readonly maxResults?: number

  /**
   * This value is populated by passing the \&#39;next_token\&#39; returned in a request to paginate through results.
   * @type {string}
   * @memberof TweetsApiGetRules
   */
  readonly paginationToken?: string
}

/**
 * Request parameters for hideReplyById operation in TweetsApi.
 * @export
 * @interface TweetsApiHideReplyByIdRequest
 */
export interface TweetsApiHideReplyByIdRequest {
  /**
   * The ID of the reply that you want to hide or unhide.
   * @type {string}
   * @memberof TweetsApiHideReplyById
   */
  readonly id: string

  /**
   *
   * @type {InlineObject3}
   * @memberof TweetsApiHideReplyById
   */
  readonly inlineObject3?: InlineObject3
}

/**
 * Request parameters for sampleStream operation in TweetsApi.
 * @export
 * @interface TweetsApiSampleStreamRequest
 */
export interface TweetsApiSampleStreamRequest {
  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiSampleStream
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiSampleStream
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiSampleStream
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>}
   * @memberof TweetsApiSampleStream
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
    | 'alt_text'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiSampleStream
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiSampleStream
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >

  /**
   * The number of minutes of backfill requested
   * @type {number}
   * @memberof TweetsApiSampleStream
   */
  readonly backfillMinutes?: number
}

/**
 * Request parameters for searchStream operation in TweetsApi.
 * @export
 * @interface TweetsApiSearchStreamRequest
 */
export interface TweetsApiSearchStreamRequest {
  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiSearchStream
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiSearchStream
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiSearchStream
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>}
   * @memberof TweetsApiSearchStream
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
    | 'alt_text'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiSearchStream
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiSearchStream
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >

  /**
   * The number of minutes of backfill requested
   * @type {number}
   * @memberof TweetsApiSearchStream
   */
  readonly backfillMinutes?: number
}

/**
 * Request parameters for tweetCountsFullArchiveSearch operation in TweetsApi.
 * @export
 * @interface TweetsApiTweetCountsFullArchiveSearchRequest
 */
export interface TweetsApiTweetCountsFullArchiveSearchRequest {
  /**
   * One query/rule/filter for matching Tweets. Up to 2048 characters.
   * @type {string}
   * @memberof TweetsApiTweetCountsFullArchiveSearch
   */
  readonly query: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
   * @type {string}
   * @memberof TweetsApiTweetCountsFullArchiveSearch
   */
  readonly startTime?: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
   * @type {string}
   * @memberof TweetsApiTweetCountsFullArchiveSearch
   */
  readonly endTime?: string

  /**
   * Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
   * @type {string}
   * @memberof TweetsApiTweetCountsFullArchiveSearch
   */
  readonly sinceId?: string

  /**
   * Returns results with a Tweet ID less than (that is, older than) the specified ID.
   * @type {string}
   * @memberof TweetsApiTweetCountsFullArchiveSearch
   */
  readonly untilId?: string

  /**
   * This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
   * @type {string}
   * @memberof TweetsApiTweetCountsFullArchiveSearch
   */
  readonly nextToken?: string

  /**
   * The granularity for the search counts results.
   * @type {Granularity}
   * @memberof TweetsApiTweetCountsFullArchiveSearch
   */
  readonly granularity?: Granularity
}

/**
 * Request parameters for tweetCountsRecentSearch operation in TweetsApi.
 * @export
 * @interface TweetsApiTweetCountsRecentSearchRequest
 */
export interface TweetsApiTweetCountsRecentSearchRequest {
  /**
   * One query/rule/filter for matching Tweets. Up to 2048 characters.
   * @type {string}
   * @memberof TweetsApiTweetCountsRecentSearch
   */
  readonly query: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
   * @type {string}
   * @memberof TweetsApiTweetCountsRecentSearch
   */
  readonly startTime?: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
   * @type {string}
   * @memberof TweetsApiTweetCountsRecentSearch
   */
  readonly endTime?: string

  /**
   * Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
   * @type {string}
   * @memberof TweetsApiTweetCountsRecentSearch
   */
  readonly sinceId?: string

  /**
   * Returns results with a Tweet ID less than (that is, older than) the specified ID.
   * @type {string}
   * @memberof TweetsApiTweetCountsRecentSearch
   */
  readonly untilId?: string

  /**
   * This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
   * @type {string}
   * @memberof TweetsApiTweetCountsRecentSearch
   */
  readonly nextToken?: string

  /**
   * The granularity for the search counts results.
   * @type {Granularity}
   * @memberof TweetsApiTweetCountsRecentSearch
   */
  readonly granularity?: Granularity
}

/**
 * Request parameters for tweetsFullarchiveSearch operation in TweetsApi.
 * @export
 * @interface TweetsApiTweetsFullarchiveSearchRequest
 */
export interface TweetsApiTweetsFullarchiveSearchRequest {
  /**
   * One query/rule/filter for matching Tweets. Up to 1024 characters.
   * @type {string}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly query: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
   * @type {string}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly startTime?: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
   * @type {string}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly endTime?: string

  /**
   * Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
   * @type {string}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly sinceId?: string

  /**
   * Returns results with a Tweet ID less than (that is, older than) the specified ID.
   * @type {string}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly untilId?: string

  /**
   * The maximum number of search results to be returned by a request.
   * @type {number}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly maxResults?: number

  /**
   * This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
   * @type {string}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly nextToken?: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
    | 'alt_text'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * Request parameters for tweetsRecentSearch operation in TweetsApi.
 * @export
 * @interface TweetsApiTweetsRecentSearchRequest
 */
export interface TweetsApiTweetsRecentSearchRequest {
  /**
   * One query/rule/filter for matching Tweets. Up to 512 characters.
   * @type {string}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly query: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
   * @type {string}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly startTime?: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
   * @type {string}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly endTime?: string

  /**
   * Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
   * @type {string}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly sinceId?: string

  /**
   * Returns results with a Tweet ID less than (that is, older than) the specified ID.
   * @type {string}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly untilId?: string

  /**
   * The maximum number of search results to be returned by a request.
   * @type {number}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly maxResults?: number

  /**
   * This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
   * @type {string}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly nextToken?: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
    | 'alt_text'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * Request parameters for usersIdLike operation in TweetsApi.
 * @export
 * @interface TweetsApiUsersIdLikeRequest
 */
export interface TweetsApiUsersIdLikeRequest {
  /**
   * The ID of the user that is requesting to like the tweet
   * @type {string}
   * @memberof TweetsApiUsersIdLike
   */
  readonly id: string

  /**
   *
   * @type {UsersLikesCreateRequest}
   * @memberof TweetsApiUsersIdLike
   */
  readonly usersLikesCreateRequest?: UsersLikesCreateRequest
}

/**
 * Request parameters for usersIdLikedTweets operation in TweetsApi.
 * @export
 * @interface TweetsApiUsersIdLikedTweetsRequest
 */
export interface TweetsApiUsersIdLikedTweetsRequest {
  /**
   * The ID of the User to list the liked Tweets of
   * @type {string}
   * @memberof TweetsApiUsersIdLikedTweets
   */
  readonly id: string

  /**
   * The maximum number of results
   * @type {number}
   * @memberof TweetsApiUsersIdLikedTweets
   */
  readonly maxResults?: number

  /**
   * This parameter is used to get the next \&#39;page\&#39; of results.
   * @type {string}
   * @memberof TweetsApiUsersIdLikedTweets
   */
  readonly paginationToken?: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiUsersIdLikedTweets
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiUsersIdLikedTweets
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiUsersIdLikedTweets
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>}
   * @memberof TweetsApiUsersIdLikedTweets
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
    | 'alt_text'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiUsersIdLikedTweets
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiUsersIdLikedTweets
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * Request parameters for usersIdMentions operation in TweetsApi.
 * @export
 * @interface TweetsApiUsersIdMentionsRequest
 */
export interface TweetsApiUsersIdMentionsRequest {
  /**
   * The ID of the User to list mentions of
   * @type {string}
   * @memberof TweetsApiUsersIdMentions
   */
  readonly id: string

  /**
   * The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
   * @type {string}
   * @memberof TweetsApiUsersIdMentions
   */
  readonly sinceId?: string

  /**
   * The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
   * @type {string}
   * @memberof TweetsApiUsersIdMentions
   */
  readonly untilId?: string

  /**
   * The maximum number of results
   * @type {number}
   * @memberof TweetsApiUsersIdMentions
   */
  readonly maxResults?: number

  /**
   * This parameter is used to get the next \&#39;page\&#39; of results.
   * @type {string}
   * @memberof TweetsApiUsersIdMentions
   */
  readonly paginationToken?: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
   * @type {string}
   * @memberof TweetsApiUsersIdMentions
   */
  readonly startTime?: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
   * @type {string}
   * @memberof TweetsApiUsersIdMentions
   */
  readonly endTime?: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiUsersIdMentions
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiUsersIdMentions
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiUsersIdMentions
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>}
   * @memberof TweetsApiUsersIdMentions
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
    | 'alt_text'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiUsersIdMentions
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiUsersIdMentions
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * Request parameters for usersIdRetweets operation in TweetsApi.
 * @export
 * @interface TweetsApiUsersIdRetweetsRequest
 */
export interface TweetsApiUsersIdRetweetsRequest {
  /**
   * The ID of the user that is requesting to retweet the tweet
   * @type {string}
   * @memberof TweetsApiUsersIdRetweets
   */
  readonly id: string

  /**
   *
   * @type {UsersRetweetsCreateRequest}
   * @memberof TweetsApiUsersIdRetweets
   */
  readonly usersRetweetsCreateRequest?: UsersRetweetsCreateRequest
}

/**
 * Request parameters for usersIdTweets operation in TweetsApi.
 * @export
 * @interface TweetsApiUsersIdTweetsRequest
 */
export interface TweetsApiUsersIdTweetsRequest {
  /**
   * The ID of the User to list Tweets of
   * @type {string}
   * @memberof TweetsApiUsersIdTweets
   */
  readonly id: string

  /**
   * The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
   * @type {string}
   * @memberof TweetsApiUsersIdTweets
   */
  readonly sinceId?: string

  /**
   * The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
   * @type {string}
   * @memberof TweetsApiUsersIdTweets
   */
  readonly untilId?: string

  /**
   * The maximum number of results
   * @type {number}
   * @memberof TweetsApiUsersIdTweets
   */
  readonly maxResults?: number

  /**
   * The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;)
   * @type {Array<'replies' | 'retweets'>}
   * @memberof TweetsApiUsersIdTweets
   */
  readonly exclude?: Array<'replies' | 'retweets'>

  /**
   * This parameter is used to get the next \&#39;page\&#39; of results.
   * @type {string}
   * @memberof TweetsApiUsersIdTweets
   */
  readonly paginationToken?: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
   * @type {string}
   * @memberof TweetsApiUsersIdTweets
   */
  readonly startTime?: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
   * @type {string}
   * @memberof TweetsApiUsersIdTweets
   */
  readonly endTime?: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiUsersIdTweets
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiUsersIdTweets
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiUsersIdTweets
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics' | 'alt_text'>}
   * @memberof TweetsApiUsersIdTweets
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
    | 'alt_text'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiUsersIdTweets
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiUsersIdTweets
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * Request parameters for usersIdUnlike operation in TweetsApi.
 * @export
 * @interface TweetsApiUsersIdUnlikeRequest
 */
export interface TweetsApiUsersIdUnlikeRequest {
  /**
   * The ID of the user that is requesting to unlike the tweet
   * @type {string}
   * @memberof TweetsApiUsersIdUnlike
   */
  readonly id: string

  /**
   * The ID of the tweet that the user is requesting to unlike
   * @type {string}
   * @memberof TweetsApiUsersIdUnlike
   */
  readonly tweetId: string
}

/**
 * Request parameters for usersIdUnretweets operation in TweetsApi.
 * @export
 * @interface TweetsApiUsersIdUnretweetsRequest
 */
export interface TweetsApiUsersIdUnretweetsRequest {
  /**
   * The ID of the user that is requesting to unretweet the tweet
   * @type {string}
   * @memberof TweetsApiUsersIdUnretweets
   */
  readonly id: string

  /**
   * The ID of the tweet that the user is requesting to unretweet
   * @type {string}
   * @memberof TweetsApiUsersIdUnretweets
   */
  readonly sourceTweetId: string
}

/**
 * TweetsApi - object-oriented interface
 * @export
 * @class TweetsApi
 * @extends {BaseAPI}
 */
export class TweetsApi extends BaseAPI {
  /**
   * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
   * @summary Add/Delete rules
   * @param {TweetsApiAddOrDeleteRulesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public addOrDeleteRules(
    requestParameters: TweetsApiAddOrDeleteRulesRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .addOrDeleteRules(
        requestParameters.addOrDeleteRulesRequest,
        requestParameters.dryRun,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a variety of information about the Tweet specified by the requested ID
   * @summary Tweet lookup by Tweet ID
   * @param {TweetsApiFindTweetByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public findTweetById(
    requestParameters: TweetsApiFindTweetByIdRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .findTweetById(
        requestParameters.id,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a variety of information about the Tweet specified by the requested ID
   * @summary Tweet lookup by Tweet IDs
   * @param {TweetsApiFindTweetsByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public findTweetsById(
    requestParameters: TweetsApiFindTweetsByIdRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .findTweetsById(
        requestParameters.ids,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
   * @summary Rules lookup
   * @param {TweetsApiGetRulesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public getRules(
    requestParameters: TweetsApiGetRulesRequest = {},
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .getRules(
        requestParameters.ids,
        requestParameters.maxResults,
        requestParameters.paginationToken,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Hides or unhides a reply to an owned conversation.
   * @summary Hide replies
   * @param {TweetsApiHideReplyByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public hideReplyById(
    requestParameters: TweetsApiHideReplyByIdRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .hideReplyById(
        requestParameters.id,
        requestParameters.inlineObject3,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Streams a deterministic 1% of public Tweets.
   * @summary Sample stream
   * @param {TweetsApiSampleStreamRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public sampleStream(
    requestParameters: TweetsApiSampleStreamRequest = {},
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .sampleStream(
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        requestParameters.backfillMinutes,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Streams Tweets matching the stream\'s active rule set.
   * @summary Filtered stream
   * @param {TweetsApiSearchStreamRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public searchStream(
    requestParameters: TweetsApiSearchStreamRequest = {},
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .searchStream(
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        requestParameters.backfillMinutes,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns Tweet Counts that match a search query.
   * @summary Full archive search counts
   * @param {TweetsApiTweetCountsFullArchiveSearchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public tweetCountsFullArchiveSearch(
    requestParameters: TweetsApiTweetCountsFullArchiveSearchRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .tweetCountsFullArchiveSearch(
        requestParameters.query,
        requestParameters.startTime,
        requestParameters.endTime,
        requestParameters.sinceId,
        requestParameters.untilId,
        requestParameters.nextToken,
        requestParameters.granularity,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns Tweet Counts from the last 7 days that match a search query.
   * @summary Recent search counts
   * @param {TweetsApiTweetCountsRecentSearchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public tweetCountsRecentSearch(
    requestParameters: TweetsApiTweetCountsRecentSearchRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .tweetCountsRecentSearch(
        requestParameters.query,
        requestParameters.startTime,
        requestParameters.endTime,
        requestParameters.sinceId,
        requestParameters.untilId,
        requestParameters.nextToken,
        requestParameters.granularity,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns Tweets that match a search query.
   * @summary Full-archive search
   * @param {TweetsApiTweetsFullarchiveSearchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public tweetsFullarchiveSearch(
    requestParameters: TweetsApiTweetsFullarchiveSearchRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .tweetsFullarchiveSearch(
        requestParameters.query,
        requestParameters.startTime,
        requestParameters.endTime,
        requestParameters.sinceId,
        requestParameters.untilId,
        requestParameters.maxResults,
        requestParameters.nextToken,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns Tweets from the last 7 days that match a search query.
   * @summary Recent search
   * @param {TweetsApiTweetsRecentSearchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public tweetsRecentSearch(
    requestParameters: TweetsApiTweetsRecentSearchRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .tweetsRecentSearch(
        requestParameters.query,
        requestParameters.startTime,
        requestParameters.endTime,
        requestParameters.sinceId,
        requestParameters.untilId,
        requestParameters.maxResults,
        requestParameters.nextToken,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Causes the user (in the path) to like the specified tweet. The user in the path must match the user context authorizing the request.
   * @summary Causes the user (in the path) to like the specified tweet
   * @param {TweetsApiUsersIdLikeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public usersIdLike(
    requestParameters: TweetsApiUsersIdLikeRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .usersIdLike(
        requestParameters.id,
        requestParameters.usersLikesCreateRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of Tweets liked by the provided User ID
   * @summary Returns Tweet objects liked by the provided User ID
   * @param {TweetsApiUsersIdLikedTweetsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public usersIdLikedTweets(
    requestParameters: TweetsApiUsersIdLikedTweetsRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .usersIdLikedTweets(
        requestParameters.id,
        requestParameters.maxResults,
        requestParameters.paginationToken,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns Tweet objects that mention username associated to the provided User ID
   * @summary User mention timeline by User ID
   * @param {TweetsApiUsersIdMentionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public usersIdMentions(
    requestParameters: TweetsApiUsersIdMentionsRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .usersIdMentions(
        requestParameters.id,
        requestParameters.sinceId,
        requestParameters.untilId,
        requestParameters.maxResults,
        requestParameters.paginationToken,
        requestParameters.startTime,
        requestParameters.endTime,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Causes the user (in the path) to retweet the specified tweet. The user in the path must match the user context authorizing the request.
   * @summary Causes the user (in the path) to retweet the specified tweet
   * @param {TweetsApiUsersIdRetweetsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public usersIdRetweets(
    requestParameters: TweetsApiUsersIdRetweetsRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .usersIdRetweets(
        requestParameters.id,
        requestParameters.usersRetweetsCreateRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of Tweets authored by the provided User ID
   * @summary User Tweets timeline by User ID
   * @param {TweetsApiUsersIdTweetsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public usersIdTweets(
    requestParameters: TweetsApiUsersIdTweetsRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .usersIdTweets(
        requestParameters.id,
        requestParameters.sinceId,
        requestParameters.untilId,
        requestParameters.maxResults,
        requestParameters.exclude,
        requestParameters.paginationToken,
        requestParameters.startTime,
        requestParameters.endTime,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Causes the user (in the path) to unlike the specified tweet. The user must match the user context authorizing the request
   * @summary Causes the user (in the path) to unlike the specified tweet
   * @param {TweetsApiUsersIdUnlikeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public usersIdUnlike(
    requestParameters: TweetsApiUsersIdUnlikeRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .usersIdUnlike(requestParameters.id, requestParameters.tweetId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Causes the user (in the path) to unretweet the specified tweet. The user must match the user context authorizing the request
   * @summary Causes the user (in the path) to unretweet the specified tweet
   * @param {TweetsApiUsersIdUnretweetsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public usersIdUnretweets(
    requestParameters: TweetsApiUsersIdUnretweetsRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .usersIdUnretweets(
        requestParameters.id,
        requestParameters.sourceTweetId,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This endpoint returns information about a user. Specify user by ID.
     * @summary User lookup by ID
     * @param {string} id Required. A User ID.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUserById: async (
      id: string,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling findUserById.',
        )
      }
      const localVarPath = `/2/users/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint returns information about a user. Specify user by username.
     * @summary User lookup by username
     * @param {string} username Required. A username.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUserByUsername: async (
      username: string,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling findUserByUsername.',
        )
      }
      const localVarPath = `/2/users/by/username/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint returns information about users. Specify users by their ID.
     * @summary User lookup by IDs
     * @param {Array<string>} ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUsersById: async (
      ids: Array<string>,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          'ids',
          'Required parameter ids was null or undefined when calling findUsersById.',
        )
      }
      const localVarPath = `/2/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (ids) {
        localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv)
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint returns information about users. Specify users by their username.
     * @summary User lookup by usernames
     * @param {Array<string>} usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUsersByUsername: async (
      usernames: Array<string>,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'usernames' is not null or undefined
      if (usernames === null || usernames === undefined) {
        throw new RequiredError(
          'usernames',
          'Required parameter usernames was null or undefined when calling findUsersByUsername.',
        )
      }
      const localVarPath = `/2/users/by`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (usernames) {
        localVarQueryParameter['usernames'] = usernames.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of users that have liked the provided Tweet ID
     * @summary Returns user objects that have liked the provided Tweet ID
     * @param {string} id The ID of the Tweet for which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsIdLikingUsers: async (
      id: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling tweetsIdLikingUsers.',
        )
      }
      const localVarPath = `/2/tweets/{id}/liking_users`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of users that have retweeted the provided Tweet ID
     * @summary Returns user objects that have retweeted the provided Tweet ID
     * @param {string} id The ID of the Tweet for which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsIdRetweetingUsers: async (
      id: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling tweetsIdRetweetingUsers.',
        )
      }
      const localVarPath = `/2/tweets/{id}/retweeted_by`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Causes the user (in the path) to block the target user. The user (in the path) must match the user context authorizing the request
     * @summary Block User by User ID
     * @param {string} id The ID of the user that is requesting to block the target user
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdBlock: async (
      id: string,
      inlineObject?: InlineObject,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdBlock.',
        )
      }
      const localVarPath = `/2/users/{id}/blocking`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserToken required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const nonString = typeof inlineObject !== 'string'
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type'],
            )
          : nonString
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(inlineObject !== undefined ? inlineObject : {})
        : inlineObject || ''

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of users that are blocked by the provided user ID
     * @summary Returns user objects that are blocked by provided user ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdBlocking: async (
      id: string,
      maxResults?: number,
      paginationToken?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdBlocking.',
        )
      }
      const localVarPath = `/2/users/{id}/blocking`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserToken required

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (paginationToken !== undefined) {
        localVarQueryParameter['pagination_token'] = paginationToken
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Causes the user(in the path) to follow, or request to follow for protected users, the target user. The user(in the path) must match the user context authorizing the request
     * @summary Follow User
     * @param {string} id The ID of the user that is requesting to follow the target user
     * @param {InlineObject2} [inlineObject2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdFollow: async (
      id: string,
      inlineObject2?: InlineObject2,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdFollow.',
        )
      }
      const localVarPath = `/2/users/{id}/following`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserToken required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const nonString = typeof inlineObject2 !== 'string'
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type'],
            )
          : nonString
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(inlineObject2 !== undefined ? inlineObject2 : {})
        : inlineObject2 || ''

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of users that follow the provided user ID
     * @summary Returns user objects that follow the provided user ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdFollowers: async (
      id: string,
      maxResults?: number,
      paginationToken?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdFollowers.',
        )
      }
      const localVarPath = `/2/users/{id}/followers`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (paginationToken !== undefined) {
        localVarQueryParameter['pagination_token'] = paginationToken
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of users that are being followed by the provided user ID
     * @summary Following by User ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdFollowing: async (
      id: string,
      maxResults?: number,
      paginationToken?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdFollowing.',
        )
      }
      const localVarPath = `/2/users/{id}/following`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (paginationToken !== undefined) {
        localVarQueryParameter['pagination_token'] = paginationToken
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Causes the user (in the path) to mute the target user. The user (in the path) must match the user context authorizing the request
     * @summary Mute User by User ID
     * @param {string} id The ID of the user that is requesting to mute the target user
     * @param {InlineObject1} [inlineObject1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdMute: async (
      id: string,
      inlineObject1?: InlineObject1,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdMute.',
        )
      }
      const localVarPath = `/2/users/{id}/muting`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserToken required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const nonString = typeof inlineObject1 !== 'string'
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type'],
            )
          : nonString
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(inlineObject1 !== undefined ? inlineObject1 : {})
        : inlineObject1 || ''

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of users that are muted by the provided user ID
     * @summary Returns user objects that are muted by the provided user ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdMuting: async (
      id: string,
      maxResults?: number,
      paginationToken?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling usersIdMuting.',
        )
      }
      const localVarPath = `/2/users/{id}/muting`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserToken required

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (paginationToken !== undefined) {
        localVarQueryParameter['pagination_token'] = paginationToken
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Causes the source user to unblock the target user. The source user must match the user context authorizing the request
     * @summary Unblock User by User ID
     * @param {string} sourceUserId The ID of the user that is requesting to unblock the target user
     * @param {string} targetUserId The ID of the user that the source user is requesting to unblock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdUnblock: async (
      sourceUserId: string,
      targetUserId: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sourceUserId' is not null or undefined
      if (sourceUserId === null || sourceUserId === undefined) {
        throw new RequiredError(
          'sourceUserId',
          'Required parameter sourceUserId was null or undefined when calling usersIdUnblock.',
        )
      }
      // verify required parameter 'targetUserId' is not null or undefined
      if (targetUserId === null || targetUserId === undefined) {
        throw new RequiredError(
          'targetUserId',
          'Required parameter targetUserId was null or undefined when calling usersIdUnblock.',
        )
      }
      const localVarPath = `/2/users/{source_user_id}/blocking/{target_user_id}`
        .replace(
          `{${'source_user_id'}}`,
          encodeURIComponent(String(sourceUserId)),
        )
        .replace(
          `{${'target_user_id'}}`,
          encodeURIComponent(String(targetUserId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserToken required

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Causes the source user to unfollow the target user. The source user must match the user context authorizing the request
     * @summary Unfollow User
     * @param {string} sourceUserId The ID of the user that is requesting to unfollow the target user
     * @param {string} targetUserId The ID of the user that the source user is requesting to unfollow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdUnfollow: async (
      sourceUserId: string,
      targetUserId: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sourceUserId' is not null or undefined
      if (sourceUserId === null || sourceUserId === undefined) {
        throw new RequiredError(
          'sourceUserId',
          'Required parameter sourceUserId was null or undefined when calling usersIdUnfollow.',
        )
      }
      // verify required parameter 'targetUserId' is not null or undefined
      if (targetUserId === null || targetUserId === undefined) {
        throw new RequiredError(
          'targetUserId',
          'Required parameter targetUserId was null or undefined when calling usersIdUnfollow.',
        )
      }
      const localVarPath =
        `/2/users/{source_user_id}/following/{target_user_id}`
          .replace(
            `{${'source_user_id'}}`,
            encodeURIComponent(String(sourceUserId)),
          )
          .replace(
            `{${'target_user_id'}}`,
            encodeURIComponent(String(targetUserId)),
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserToken required

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Causes the source user to unmute the target user. The source user must match the user context authorizing the request
     * @summary Unmute User by User ID
     * @param {string} sourceUserId The ID of the user that is requesting to unmute the target user
     * @param {string} targetUserId The ID of the user that the source user is requesting to unmute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdUnmute: async (
      sourceUserId: string,
      targetUserId: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sourceUserId' is not null or undefined
      if (sourceUserId === null || sourceUserId === undefined) {
        throw new RequiredError(
          'sourceUserId',
          'Required parameter sourceUserId was null or undefined when calling usersIdUnmute.',
        )
      }
      // verify required parameter 'targetUserId' is not null or undefined
      if (targetUserId === null || targetUserId === undefined) {
        throw new RequiredError(
          'targetUserId',
          'Required parameter targetUserId was null or undefined when calling usersIdUnmute.',
        )
      }
      const localVarPath = `/2/users/{source_user_id}/muting/{target_user_id}`
        .replace(
          `{${'source_user_id'}}`,
          encodeURIComponent(String(sourceUserId)),
        )
        .replace(
          `{${'target_user_id'}}`,
          encodeURIComponent(String(targetUserId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserToken required

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint returns information about a user. Specify user by ID.
     * @summary User lookup by ID
     * @param {string} id Required. A User ID.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findUserById(
      id: string,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SingleUserLookupResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).findUserById(id, expansions, tweetFields, userFields, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * This endpoint returns information about a user. Specify user by username.
     * @summary User lookup by username
     * @param {string} username Required. A username.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findUserByUsername(
      username: string,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SingleUserLookupResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).findUserByUsername(
        username,
        expansions,
        tweetFields,
        userFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * This endpoint returns information about users. Specify users by their ID.
     * @summary User lookup by IDs
     * @param {Array<string>} ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findUsersById(
      ids: Array<string>,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MultiUserLookupResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).findUsersById(ids, expansions, tweetFields, userFields, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * This endpoint returns information about users. Specify users by their username.
     * @summary User lookup by usernames
     * @param {Array<string>} usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findUsersByUsername(
      usernames: Array<string>,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MultiUserLookupResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).findUsersByUsername(
        usernames,
        expansions,
        tweetFields,
        userFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a list of users that have liked the provided Tweet ID
     * @summary Returns user objects that have liked the provided Tweet ID
     * @param {string} id The ID of the Tweet for which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tweetsIdLikingUsers(
      id: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GenericMultipleUsersLookupResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).tweetsIdLikingUsers(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a list of users that have retweeted the provided Tweet ID
     * @summary Returns user objects that have retweeted the provided Tweet ID
     * @param {string} id The ID of the Tweet for which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tweetsIdRetweetingUsers(
      id: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GenericMultipleUsersLookupResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).tweetsIdRetweetingUsers(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Causes the user (in the path) to block the target user. The user (in the path) must match the user context authorizing the request
     * @summary Block User by User ID
     * @param {string} id The ID of the user that is requesting to block the target user
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdBlock(
      id: string,
      inlineObject?: InlineObject,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UsersBlockingMutationResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).usersIdBlock(id, inlineObject, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a list of users that are blocked by the provided user ID
     * @summary Returns user objects that are blocked by provided user ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdBlocking(
      id: string,
      maxResults?: number,
      paginationToken?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GenericMultipleUsersLookupResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).usersIdBlocking(id, maxResults, paginationToken, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Causes the user(in the path) to follow, or request to follow for protected users, the target user. The user(in the path) must match the user context authorizing the request
     * @summary Follow User
     * @param {string} id The ID of the user that is requesting to follow the target user
     * @param {InlineObject2} [inlineObject2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdFollow(
      id: string,
      inlineObject2?: InlineObject2,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UsersFollowingCreateResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).usersIdFollow(id, inlineObject2, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a list of users that follow the provided user ID
     * @summary Returns user objects that follow the provided user ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdFollowers(
      id: string,
      maxResults?: number,
      paginationToken?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GenericMultipleUsersLookupResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).usersIdFollowers(id, maxResults, paginationToken, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a list of users that are being followed by the provided user ID
     * @summary Following by User ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdFollowing(
      id: string,
      maxResults?: number,
      paginationToken?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UsersFollowingLookupResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).usersIdFollowing(id, maxResults, paginationToken, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Causes the user (in the path) to mute the target user. The user (in the path) must match the user context authorizing the request
     * @summary Mute User by User ID
     * @param {string} id The ID of the user that is requesting to mute the target user
     * @param {InlineObject1} [inlineObject1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdMute(
      id: string,
      inlineObject1?: InlineObject1,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UsersMutingMutationResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).usersIdMute(id, inlineObject1, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a list of users that are muted by the provided user ID
     * @summary Returns user objects that are muted by the provided user ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdMuting(
      id: string,
      maxResults?: number,
      paginationToken?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GenericMultipleUsersLookupResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).usersIdMuting(id, maxResults, paginationToken, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Causes the source user to unblock the target user. The source user must match the user context authorizing the request
     * @summary Unblock User by User ID
     * @param {string} sourceUserId The ID of the user that is requesting to unblock the target user
     * @param {string} targetUserId The ID of the user that the source user is requesting to unblock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdUnblock(
      sourceUserId: string,
      targetUserId: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UsersBlockingMutationResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).usersIdUnblock(sourceUserId, targetUserId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Causes the source user to unfollow the target user. The source user must match the user context authorizing the request
     * @summary Unfollow User
     * @param {string} sourceUserId The ID of the user that is requesting to unfollow the target user
     * @param {string} targetUserId The ID of the user that the source user is requesting to unfollow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdUnfollow(
      sourceUserId: string,
      targetUserId: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UsersFollowingDeleteResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).usersIdUnfollow(sourceUserId, targetUserId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Causes the source user to unmute the target user. The source user must match the user context authorizing the request
     * @summary Unmute User by User ID
     * @param {string} sourceUserId The ID of the user that is requesting to unmute the target user
     * @param {string} targetUserId The ID of the user that the source user is requesting to unmute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdUnmute(
      sourceUserId: string,
      targetUserId: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UsersMutingMutationResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).usersIdUnmute(sourceUserId, targetUserId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * This endpoint returns information about a user. Specify user by ID.
     * @summary User lookup by ID
     * @param {string} id Required. A User ID.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUserById(
      id: string,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): AxiosPromise<SingleUserLookupResponse> {
      return UsersApiFp(configuration)
        .findUserById(id, expansions, tweetFields, userFields, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint returns information about a user. Specify user by username.
     * @summary User lookup by username
     * @param {string} username Required. A username.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUserByUsername(
      username: string,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): AxiosPromise<SingleUserLookupResponse> {
      return UsersApiFp(configuration)
        .findUserByUsername(
          username,
          expansions,
          tweetFields,
          userFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint returns information about users. Specify users by their ID.
     * @summary User lookup by IDs
     * @param {Array<string>} ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUsersById(
      ids: Array<string>,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): AxiosPromise<MultiUserLookupResponse> {
      return UsersApiFp(configuration)
        .findUsersById(ids, expansions, tweetFields, userFields, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint returns information about users. Specify users by their username.
     * @summary User lookup by usernames
     * @param {Array<string>} usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUsersByUsername(
      usernames: Array<string>,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): AxiosPromise<MultiUserLookupResponse> {
      return UsersApiFp(configuration)
        .findUsersByUsername(
          usernames,
          expansions,
          tweetFields,
          userFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of users that have liked the provided Tweet ID
     * @summary Returns user objects that have liked the provided Tweet ID
     * @param {string} id The ID of the Tweet for which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsIdLikingUsers(
      id: string,
      options?: any,
    ): AxiosPromise<GenericMultipleUsersLookupResponse> {
      return UsersApiFp(configuration)
        .tweetsIdLikingUsers(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of users that have retweeted the provided Tweet ID
     * @summary Returns user objects that have retweeted the provided Tweet ID
     * @param {string} id The ID of the Tweet for which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsIdRetweetingUsers(
      id: string,
      options?: any,
    ): AxiosPromise<GenericMultipleUsersLookupResponse> {
      return UsersApiFp(configuration)
        .tweetsIdRetweetingUsers(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Causes the user (in the path) to block the target user. The user (in the path) must match the user context authorizing the request
     * @summary Block User by User ID
     * @param {string} id The ID of the user that is requesting to block the target user
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdBlock(
      id: string,
      inlineObject?: InlineObject,
      options?: any,
    ): AxiosPromise<UsersBlockingMutationResponse> {
      return UsersApiFp(configuration)
        .usersIdBlock(id, inlineObject, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of users that are blocked by the provided user ID
     * @summary Returns user objects that are blocked by provided user ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdBlocking(
      id: string,
      maxResults?: number,
      paginationToken?: string,
      options?: any,
    ): AxiosPromise<GenericMultipleUsersLookupResponse> {
      return UsersApiFp(configuration)
        .usersIdBlocking(id, maxResults, paginationToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Causes the user(in the path) to follow, or request to follow for protected users, the target user. The user(in the path) must match the user context authorizing the request
     * @summary Follow User
     * @param {string} id The ID of the user that is requesting to follow the target user
     * @param {InlineObject2} [inlineObject2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdFollow(
      id: string,
      inlineObject2?: InlineObject2,
      options?: any,
    ): AxiosPromise<UsersFollowingCreateResponse> {
      return UsersApiFp(configuration)
        .usersIdFollow(id, inlineObject2, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of users that follow the provided user ID
     * @summary Returns user objects that follow the provided user ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdFollowers(
      id: string,
      maxResults?: number,
      paginationToken?: string,
      options?: any,
    ): AxiosPromise<GenericMultipleUsersLookupResponse> {
      return UsersApiFp(configuration)
        .usersIdFollowers(id, maxResults, paginationToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of users that are being followed by the provided user ID
     * @summary Following by User ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdFollowing(
      id: string,
      maxResults?: number,
      paginationToken?: string,
      options?: any,
    ): AxiosPromise<UsersFollowingLookupResponse> {
      return UsersApiFp(configuration)
        .usersIdFollowing(id, maxResults, paginationToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Causes the user (in the path) to mute the target user. The user (in the path) must match the user context authorizing the request
     * @summary Mute User by User ID
     * @param {string} id The ID of the user that is requesting to mute the target user
     * @param {InlineObject1} [inlineObject1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdMute(
      id: string,
      inlineObject1?: InlineObject1,
      options?: any,
    ): AxiosPromise<UsersMutingMutationResponse> {
      return UsersApiFp(configuration)
        .usersIdMute(id, inlineObject1, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of users that are muted by the provided user ID
     * @summary Returns user objects that are muted by the provided user ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdMuting(
      id: string,
      maxResults?: number,
      paginationToken?: string,
      options?: any,
    ): AxiosPromise<GenericMultipleUsersLookupResponse> {
      return UsersApiFp(configuration)
        .usersIdMuting(id, maxResults, paginationToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Causes the source user to unblock the target user. The source user must match the user context authorizing the request
     * @summary Unblock User by User ID
     * @param {string} sourceUserId The ID of the user that is requesting to unblock the target user
     * @param {string} targetUserId The ID of the user that the source user is requesting to unblock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdUnblock(
      sourceUserId: string,
      targetUserId: string,
      options?: any,
    ): AxiosPromise<UsersBlockingMutationResponse> {
      return UsersApiFp(configuration)
        .usersIdUnblock(sourceUserId, targetUserId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Causes the source user to unfollow the target user. The source user must match the user context authorizing the request
     * @summary Unfollow User
     * @param {string} sourceUserId The ID of the user that is requesting to unfollow the target user
     * @param {string} targetUserId The ID of the user that the source user is requesting to unfollow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdUnfollow(
      sourceUserId: string,
      targetUserId: string,
      options?: any,
    ): AxiosPromise<UsersFollowingDeleteResponse> {
      return UsersApiFp(configuration)
        .usersIdUnfollow(sourceUserId, targetUserId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Causes the source user to unmute the target user. The source user must match the user context authorizing the request
     * @summary Unmute User by User ID
     * @param {string} sourceUserId The ID of the user that is requesting to unmute the target user
     * @param {string} targetUserId The ID of the user that the source user is requesting to unmute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdUnmute(
      sourceUserId: string,
      targetUserId: string,
      options?: any,
    ): AxiosPromise<UsersMutingMutationResponse> {
      return UsersApiFp(configuration)
        .usersIdUnmute(sourceUserId, targetUserId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for findUserById operation in UsersApi.
 * @export
 * @interface UsersApiFindUserByIdRequest
 */
export interface UsersApiFindUserByIdRequest {
  /**
   * Required. A User ID.
   * @type {string}
   * @memberof UsersApiFindUserById
   */
  readonly id: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'pinned_tweet_id'>}
   * @memberof UsersApiFindUserById
   */
  readonly expansions?: Array<'pinned_tweet_id'>

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof UsersApiFindUserById
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof UsersApiFindUserById
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >
}

/**
 * Request parameters for findUserByUsername operation in UsersApi.
 * @export
 * @interface UsersApiFindUserByUsernameRequest
 */
export interface UsersApiFindUserByUsernameRequest {
  /**
   * Required. A username.
   * @type {string}
   * @memberof UsersApiFindUserByUsername
   */
  readonly username: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'pinned_tweet_id'>}
   * @memberof UsersApiFindUserByUsername
   */
  readonly expansions?: Array<'pinned_tweet_id'>

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof UsersApiFindUserByUsername
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof UsersApiFindUserByUsername
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >
}

/**
 * Request parameters for findUsersById operation in UsersApi.
 * @export
 * @interface UsersApiFindUsersByIdRequest
 */
export interface UsersApiFindUsersByIdRequest {
  /**
   * Required. A list of User IDs, comma-separated. You can specify up to 100 IDs.
   * @type {Array<string>}
   * @memberof UsersApiFindUsersById
   */
  readonly ids: Array<string>

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'pinned_tweet_id'>}
   * @memberof UsersApiFindUsersById
   */
  readonly expansions?: Array<'pinned_tweet_id'>

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof UsersApiFindUsersById
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof UsersApiFindUsersById
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >
}

/**
 * Request parameters for findUsersByUsername operation in UsersApi.
 * @export
 * @interface UsersApiFindUsersByUsernameRequest
 */
export interface UsersApiFindUsersByUsernameRequest {
  /**
   * Required . A list of usernames, comma-separated. You can specify up to 100 usernames.
   * @type {Array<string>}
   * @memberof UsersApiFindUsersByUsername
   */
  readonly usernames: Array<string>

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'pinned_tweet_id'>}
   * @memberof UsersApiFindUsersByUsername
   */
  readonly expansions?: Array<'pinned_tweet_id'>

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof UsersApiFindUsersByUsername
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof UsersApiFindUsersByUsername
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >
}

/**
 * Request parameters for tweetsIdLikingUsers operation in UsersApi.
 * @export
 * @interface UsersApiTweetsIdLikingUsersRequest
 */
export interface UsersApiTweetsIdLikingUsersRequest {
  /**
   * The ID of the Tweet for which to return results
   * @type {string}
   * @memberof UsersApiTweetsIdLikingUsers
   */
  readonly id: string
}

/**
 * Request parameters for tweetsIdRetweetingUsers operation in UsersApi.
 * @export
 * @interface UsersApiTweetsIdRetweetingUsersRequest
 */
export interface UsersApiTweetsIdRetweetingUsersRequest {
  /**
   * The ID of the Tweet for which to return results
   * @type {string}
   * @memberof UsersApiTweetsIdRetweetingUsers
   */
  readonly id: string
}

/**
 * Request parameters for usersIdBlock operation in UsersApi.
 * @export
 * @interface UsersApiUsersIdBlockRequest
 */
export interface UsersApiUsersIdBlockRequest {
  /**
   * The ID of the user that is requesting to block the target user
   * @type {string}
   * @memberof UsersApiUsersIdBlock
   */
  readonly id: string

  /**
   *
   * @type {InlineObject}
   * @memberof UsersApiUsersIdBlock
   */
  readonly inlineObject?: InlineObject
}

/**
 * Request parameters for usersIdBlocking operation in UsersApi.
 * @export
 * @interface UsersApiUsersIdBlockingRequest
 */
export interface UsersApiUsersIdBlockingRequest {
  /**
   * The ID of the user for whom to return results
   * @type {string}
   * @memberof UsersApiUsersIdBlocking
   */
  readonly id: string

  /**
   * The maximum number of results
   * @type {number}
   * @memberof UsersApiUsersIdBlocking
   */
  readonly maxResults?: number

  /**
   * This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
   * @type {string}
   * @memberof UsersApiUsersIdBlocking
   */
  readonly paginationToken?: string
}

/**
 * Request parameters for usersIdFollow operation in UsersApi.
 * @export
 * @interface UsersApiUsersIdFollowRequest
 */
export interface UsersApiUsersIdFollowRequest {
  /**
   * The ID of the user that is requesting to follow the target user
   * @type {string}
   * @memberof UsersApiUsersIdFollow
   */
  readonly id: string

  /**
   *
   * @type {InlineObject2}
   * @memberof UsersApiUsersIdFollow
   */
  readonly inlineObject2?: InlineObject2
}

/**
 * Request parameters for usersIdFollowers operation in UsersApi.
 * @export
 * @interface UsersApiUsersIdFollowersRequest
 */
export interface UsersApiUsersIdFollowersRequest {
  /**
   * The ID of the user for whom to return results
   * @type {string}
   * @memberof UsersApiUsersIdFollowers
   */
  readonly id: string

  /**
   * The maximum number of results
   * @type {number}
   * @memberof UsersApiUsersIdFollowers
   */
  readonly maxResults?: number

  /**
   * This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
   * @type {string}
   * @memberof UsersApiUsersIdFollowers
   */
  readonly paginationToken?: string
}

/**
 * Request parameters for usersIdFollowing operation in UsersApi.
 * @export
 * @interface UsersApiUsersIdFollowingRequest
 */
export interface UsersApiUsersIdFollowingRequest {
  /**
   * The ID of the user for whom to return results
   * @type {string}
   * @memberof UsersApiUsersIdFollowing
   */
  readonly id: string

  /**
   * The maximum number of results
   * @type {number}
   * @memberof UsersApiUsersIdFollowing
   */
  readonly maxResults?: number

  /**
   * This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
   * @type {string}
   * @memberof UsersApiUsersIdFollowing
   */
  readonly paginationToken?: string
}

/**
 * Request parameters for usersIdMute operation in UsersApi.
 * @export
 * @interface UsersApiUsersIdMuteRequest
 */
export interface UsersApiUsersIdMuteRequest {
  /**
   * The ID of the user that is requesting to mute the target user
   * @type {string}
   * @memberof UsersApiUsersIdMute
   */
  readonly id: string

  /**
   *
   * @type {InlineObject1}
   * @memberof UsersApiUsersIdMute
   */
  readonly inlineObject1?: InlineObject1
}

/**
 * Request parameters for usersIdMuting operation in UsersApi.
 * @export
 * @interface UsersApiUsersIdMutingRequest
 */
export interface UsersApiUsersIdMutingRequest {
  /**
   * The ID of the user for whom to return results
   * @type {string}
   * @memberof UsersApiUsersIdMuting
   */
  readonly id: string

  /**
   * The maximum number of results
   * @type {number}
   * @memberof UsersApiUsersIdMuting
   */
  readonly maxResults?: number

  /**
   * This parameter is used to get the next \&#39;page\&#39; of results.
   * @type {string}
   * @memberof UsersApiUsersIdMuting
   */
  readonly paginationToken?: string
}

/**
 * Request parameters for usersIdUnblock operation in UsersApi.
 * @export
 * @interface UsersApiUsersIdUnblockRequest
 */
export interface UsersApiUsersIdUnblockRequest {
  /**
   * The ID of the user that is requesting to unblock the target user
   * @type {string}
   * @memberof UsersApiUsersIdUnblock
   */
  readonly sourceUserId: string

  /**
   * The ID of the user that the source user is requesting to unblock
   * @type {string}
   * @memberof UsersApiUsersIdUnblock
   */
  readonly targetUserId: string
}

/**
 * Request parameters for usersIdUnfollow operation in UsersApi.
 * @export
 * @interface UsersApiUsersIdUnfollowRequest
 */
export interface UsersApiUsersIdUnfollowRequest {
  /**
   * The ID of the user that is requesting to unfollow the target user
   * @type {string}
   * @memberof UsersApiUsersIdUnfollow
   */
  readonly sourceUserId: string

  /**
   * The ID of the user that the source user is requesting to unfollow
   * @type {string}
   * @memberof UsersApiUsersIdUnfollow
   */
  readonly targetUserId: string
}

/**
 * Request parameters for usersIdUnmute operation in UsersApi.
 * @export
 * @interface UsersApiUsersIdUnmuteRequest
 */
export interface UsersApiUsersIdUnmuteRequest {
  /**
   * The ID of the user that is requesting to unmute the target user
   * @type {string}
   * @memberof UsersApiUsersIdUnmute
   */
  readonly sourceUserId: string

  /**
   * The ID of the user that the source user is requesting to unmute
   * @type {string}
   * @memberof UsersApiUsersIdUnmute
   */
  readonly targetUserId: string
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * This endpoint returns information about a user. Specify user by ID.
   * @summary User lookup by ID
   * @param {UsersApiFindUserByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public findUserById(
    requestParameters: UsersApiFindUserByIdRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .findUserById(
        requestParameters.id,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint returns information about a user. Specify user by username.
   * @summary User lookup by username
   * @param {UsersApiFindUserByUsernameRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public findUserByUsername(
    requestParameters: UsersApiFindUserByUsernameRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .findUserByUsername(
        requestParameters.username,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint returns information about users. Specify users by their ID.
   * @summary User lookup by IDs
   * @param {UsersApiFindUsersByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public findUsersById(
    requestParameters: UsersApiFindUsersByIdRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .findUsersById(
        requestParameters.ids,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint returns information about users. Specify users by their username.
   * @summary User lookup by usernames
   * @param {UsersApiFindUsersByUsernameRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public findUsersByUsername(
    requestParameters: UsersApiFindUsersByUsernameRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .findUsersByUsername(
        requestParameters.usernames,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of users that have liked the provided Tweet ID
   * @summary Returns user objects that have liked the provided Tweet ID
   * @param {UsersApiTweetsIdLikingUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public tweetsIdLikingUsers(
    requestParameters: UsersApiTweetsIdLikingUsersRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .tweetsIdLikingUsers(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of users that have retweeted the provided Tweet ID
   * @summary Returns user objects that have retweeted the provided Tweet ID
   * @param {UsersApiTweetsIdRetweetingUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public tweetsIdRetweetingUsers(
    requestParameters: UsersApiTweetsIdRetweetingUsersRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .tweetsIdRetweetingUsers(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Causes the user (in the path) to block the target user. The user (in the path) must match the user context authorizing the request
   * @summary Block User by User ID
   * @param {UsersApiUsersIdBlockRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersIdBlock(
    requestParameters: UsersApiUsersIdBlockRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .usersIdBlock(
        requestParameters.id,
        requestParameters.inlineObject,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of users that are blocked by the provided user ID
   * @summary Returns user objects that are blocked by provided user ID
   * @param {UsersApiUsersIdBlockingRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersIdBlocking(
    requestParameters: UsersApiUsersIdBlockingRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .usersIdBlocking(
        requestParameters.id,
        requestParameters.maxResults,
        requestParameters.paginationToken,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Causes the user(in the path) to follow, or request to follow for protected users, the target user. The user(in the path) must match the user context authorizing the request
   * @summary Follow User
   * @param {UsersApiUsersIdFollowRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersIdFollow(
    requestParameters: UsersApiUsersIdFollowRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .usersIdFollow(
        requestParameters.id,
        requestParameters.inlineObject2,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of users that follow the provided user ID
   * @summary Returns user objects that follow the provided user ID
   * @param {UsersApiUsersIdFollowersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersIdFollowers(
    requestParameters: UsersApiUsersIdFollowersRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .usersIdFollowers(
        requestParameters.id,
        requestParameters.maxResults,
        requestParameters.paginationToken,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of users that are being followed by the provided user ID
   * @summary Following by User ID
   * @param {UsersApiUsersIdFollowingRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersIdFollowing(
    requestParameters: UsersApiUsersIdFollowingRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .usersIdFollowing(
        requestParameters.id,
        requestParameters.maxResults,
        requestParameters.paginationToken,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Causes the user (in the path) to mute the target user. The user (in the path) must match the user context authorizing the request
   * @summary Mute User by User ID
   * @param {UsersApiUsersIdMuteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersIdMute(
    requestParameters: UsersApiUsersIdMuteRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .usersIdMute(
        requestParameters.id,
        requestParameters.inlineObject1,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of users that are muted by the provided user ID
   * @summary Returns user objects that are muted by the provided user ID
   * @param {UsersApiUsersIdMutingRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersIdMuting(
    requestParameters: UsersApiUsersIdMutingRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .usersIdMuting(
        requestParameters.id,
        requestParameters.maxResults,
        requestParameters.paginationToken,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Causes the source user to unblock the target user. The source user must match the user context authorizing the request
   * @summary Unblock User by User ID
   * @param {UsersApiUsersIdUnblockRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersIdUnblock(
    requestParameters: UsersApiUsersIdUnblockRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .usersIdUnblock(
        requestParameters.sourceUserId,
        requestParameters.targetUserId,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Causes the source user to unfollow the target user. The source user must match the user context authorizing the request
   * @summary Unfollow User
   * @param {UsersApiUsersIdUnfollowRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersIdUnfollow(
    requestParameters: UsersApiUsersIdUnfollowRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .usersIdUnfollow(
        requestParameters.sourceUserId,
        requestParameters.targetUserId,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Causes the source user to unmute the target user. The source user must match the user context authorizing the request
   * @summary Unmute User by User ID
   * @param {UsersApiUsersIdUnmuteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersIdUnmute(
    requestParameters: UsersApiUsersIdUnmuteRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .usersIdUnmute(
        requestParameters.sourceUserId,
        requestParameters.targetUserId,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}
